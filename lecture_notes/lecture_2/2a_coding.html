<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 2</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ivan Rudik" />
    <script src="2a_coding_files/header-attrs/header-attrs.js"></script>
    <link href="2a_coding_files/remark-css/default.css" rel="stylesheet" />
    <link href="2a_coding_files/remark-css/metropolis.css" rel="stylesheet" />
    <link href="2a_coding_files/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="my-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Lecture 2
## Shell and Julia
### Ivan Rudik
### AEM 7130

---

name: toc



---

# Software and stuff

Necessary things to do:

- Windows users: Install [Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10)

- Install [Julia](https://julialang.org/downloads/)

- Install these Julia packages: `Expectations, Distributions, LinearAlgebra`

--

These slides are based on QuantEcon, Julia documentation, etc

---

# Why learn the shell?

What is the shell?

The shell is the interface for interacting with your operating system,  
typically we are referring to the command line interface (terminal, command prompt, bash, etc)

--

A lot of what you can do in the shell can be done in Julia itself, why bother with it?

---

# Why learn the shell?

- Not everything can be done directily in your usual programming language
--

- Command line is fast, powerful, and relatively easy to use,  
especially with modern shells like zsh or fish
--

- Writing shell scripts is reproducible and fast, unlike clicking buttons on a GUI
--

- If you want to use servers or any high performance computing you are likely to need to use shell 

---

# Why learn the shell?

- You can automate your entire research pipeline with shell scripts (e.g. write something that calls multiple languages to execute your code then compiles your latex for the paper)
--

- It really gets to the fundamentals of interacting with a computer (loops, tab-completions, saving scripts, etc)
--

- It gets you understanding how to write code in terms of functions which will be important for any programming you do in scripting languages like Julia, R, MATLAB, or Stata

---

# What is the shell?

The shell is basically just a program where you can  
type in commands to interact with the **kernel** and hardware

&lt;div align="center"&gt;
  &lt;img src="/figures/shell.png" height=450&gt;
&lt;/div&gt;

---

# What is the shell?

The most common one is **bash**, Bourne again shell, because it comes default on Macs and Linux

--

I use **fish**, friendly interactive shell, because it comes default with a lot of nice features,  
all the commands still work identically to bash

---

# Shell basics

When you open up the shell you should see a prompt, usually starting with `$ ` (don't type this)

```bash
$ 
```

--

We can type in one .hi-blue[command], `ls` which lists the contents of your current directory

```bash
$ ls
```

```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
```

---

# Shell basics

Commands come with potential .hi-blue[options] or .hi-blue[flags] that modify how they act

```bash
$ ls
```

```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
```

```bash
$ ls -l
```

```
## total 368
## -rw-r--r--@ 1 ir229  staff  47395 Jan 26 16:34 2a_coding.Rmd
## -rw-r--r--  1 ir229  staff  86995 Jan 26 16:33 2a_coding.html
## drwxr-xr-x  6 ir229  staff    192 Jan 26 16:33 2a_coding_files
## drwxr-xr-x  5 ir229  staff    160 Jan 26 10:16 figures
## -rw-r--r--@ 1 ir229  staff   6573 Jan 22 12:44 my-css.css
## drwxr-xr-x  8 ir229  staff    256 Jan 26 16:34 sandbox
```

---

# Shell basics

Options start with a dash and then  
a sequence of letters denoting which options you want

e.g. this lists files in long form `l`, sorted descending by size (`S`), with sizes in a human-readable format (`h`)


```bash
$ ls -lSh
```

```
## total 368
## -rw-r--r--  1 ir229  staff    85K Jan 26 16:33 2a_coding.html
## -rw-r--r--@ 1 ir229  staff    46K Jan 26 16:34 2a_coding.Rmd
## -rw-r--r--@ 1 ir229  staff   6.4K Jan 22 12:44 my-css.css
## drwxr-xr-x  8 ir229  staff   256B Jan 26 16:34 sandbox
## drwxr-xr-x  6 ir229  staff   192B Jan 26 16:33 2a_coding_files
## drwxr-xr-x  5 ir229  staff   160B Jan 26 10:16 figures
```

---

# Shell basics

Finally commands have an **argument** that the command operates on, the previous `ls` calls were operating on the current directory, but we could use it on any directory we want


```bash
$ ls -lSh ~/Desktop/git
```

```
## total 0
## drwxr-xr-x  98 ir229  staff   3.1K Mar  2  2018 rec_markets
## drwxr-xr-x  64 ir229  staff   2.0K Nov 15  2018 lrr-mcmc-dice
## drwxr-xr-x@ 45 ir229  staff   1.4K Mar  4  2018 rc_paper
## drwxr-xr-x  44 ir229  staff   1.4K May 20  2019 steering-the-climate-system
## drwxr-xr-x  40 ir229  staff   1.3K Dec  1  2018 hr_recs
## drwxr-xr-x  30 ir229  staff   960B Jul 19  2019 robust-control-jl
## drwxr-xr-x  26 ir229  staff   832B May 20  2019 dynamic-stochastic-dice
## drwxr-xr-x  26 ir229  staff   832B Jan 19 16:10 optimal-climate-policy
## drwxr-xr-x  24 ir229  staff   768B Mar 12  2019 ND-Flaring
## drwxr-xr-x  24 ir229  staff   768B Sep 30 20:43 optimal-climate-policy-aej
## drwxr-xr-x  19 ir229  staff   608B Jan 15 18:23 irudik.github.io
## drwxr-xr-x  15 ir229  staff   480B Jan 24 11:00 hurricane_forecasts
## drwxr-xr-x  13 ir229  staff   416B Jan  9 12:28 seere-lab
## drwxr-xr-x  11 ir229  staff   352B Apr 29  2019 drillinginfo-data-import
## drwxr-xr-x  11 ir229  staff   352B Jan 21 21:11 ed_rubin_class
## drwxr-xr-x  11 ir229  staff   352B Aug 18 17:13 growth-versus-levels
## drwxr-xr-x  11 ir229  staff   352B Jan 20 12:51 purple_air
## drwxr-xr-x  10 ir229  staff   320B May 20  2019 external-impacts-rps
## drwxr-xr-x  10 ir229  staff   320B Sep 17 19:23 nascar_and_lead
## drwxr-xr-x   9 ir229  staff   288B Oct 27 18:05 aem-7xxx
## drwxr-xr-x   6 ir229  staff   192B May  7  2019 workflow
## drwxr-xr-x   5 ir229  staff   160B Jan 19 15:42 aem7130
## drwxr-xr-x   5 ir229  staff   160B Feb  1  2018 climate-learning-hpc
```

---

# Shell basics

To see what commands and their options do, use the `man` (manual) command

`q` exits the man page, and spacebar lets you skip down by a page

```bash
$ man ls
```

```
## 
## LS(1)                     BSD General Commands Manual                    LS(1)
## 
## NNAAMMEE
##      llss -- list directory contents
## 
## SSYYNNOOPPSSIISS
##      llss [--AABBCCFFGGHHLLOOPPRRSSTTUUWW@@aabbccddeeffgghhiikkllmmnnooppqqrrssttuuwwxx11] [_f_i_l_e _._._.]
## 
## DDEESSCCRRIIPPTTIIOONN
##      For each operand that names a _f_i_l_e of a type other than directory, llss
##      displays its name as well as any requested, associated information.  For
##      each operand that names a _f_i_l_e of type directory, llss displays the names
##      of files contained within that directory, as well as any requested, asso-
##      ciated information.
## 
##      If no operands are given, the contents of the current directory are dis-
##      played.  If more than one operand is given, non-directory operands are
##      displayed first; directory and non-directory operands are sorted sepa-
##      rately and in lexicographical order.
## 
##      The following options are available:
## 
##      --@@      Display extended attribute keys and sizes in long (--ll) output.
## 
##      --11      (The numeric digit ``one''.)  Force output to be one entry per
##              line.  This is the default when output is not to a terminal.
## 
##      --AA      List all entries except for _. and _._..  Always set for the super-
##              user.
## 
##      --aa      Include directory entries whose names begin with a dot (_.).
## 
##      --BB      Force printing of non-printable characters (as defined by
##              ctype(3) and current locale settings) in file names as \_x_x_x,
##              where _x_x_x is the numeric value of the character in octal.
## 
##      --bb      As --BB, but use C escape codes whenever possible.
## 
##      --CC      Force multi-column output; this is the default when output is to
##              a terminal.
## 
##      --cc      Use time when file status was last changed for sorting (--tt) or
##              long printing (--ll).
## 
##      --dd      Directories are listed as plain files (not searched recursively).
## 
##      --ee      Print the Access Control List (ACL) associated with the file, if
##              present, in long (--ll) output.
## 
##      --FF      Display a slash (`/') immediately after each pathname that is a
##              directory, an asterisk (`*') after each that is executable, an at
##              sign (`@') after each symbolic link, an equals sign (`=') after
##              each socket, a percent sign (`%') after each whiteout, and a ver-
##              tical bar (`|') after each that is a FIFO.
## 
##      --ff      Output is not sorted.  This option turns on the --aa option.
## 
##      --GG      Enable colorized output.  This option is equivalent to defining
##              CLICOLOR in the environment.  (See below.)
## 
##      --gg      This option is only available for compatibility with POSIX; it is
##              used to display the group name in the long (--ll) format output
##              (the owner name is suppressed).
## 
##      --HH      Symbolic links on the command line are followed.  This option is
##              assumed if none of the --FF, --dd, or --ll options are specified.
## 
##      --hh      When used with the --ll option, use unit suffixes: Byte, Kilobyte,
##              Megabyte, Gigabyte, Terabyte and Petabyte in order to reduce the
##              number of digits to three or less using base 2 for sizes.
## 
##      --ii      For each file, print the file's file serial number (inode num-
##              ber).
## 
##      --kk      If the --ss option is specified, print the file size allocation in
##              kilobytes, not blocks.  This option overrides the environment
##              variable BLOCKSIZE.
## 
##      --LL      Follow all symbolic links to final target and list the file or
##              directory the link references rather than the link itself.  This
##              option cancels the --PP option.
## 
##      --ll      (The lowercase letter ``ell''.)  List in long format.  (See
##              below.)  If the output is to a terminal, a total sum for all the
##              file sizes is output on a line before the long listing.
## 
##      --mm      Stream output format; list files across the page, separated by
##              commas.
## 
##      --nn      Display user and group IDs numerically, rather than converting to
##              a user or group name in a long (--ll) output.  This option turns on
##              the --ll option.
## 
##      --OO      Include the file flags in a long (--ll) output.
## 
##      --oo      List in long format, but omit the group id.
## 
##      --PP      If argument is a symbolic link, list the link itself rather than
##              the object the link references.  This option cancels the --HH and
##              --LL options.
## 
##      --pp      Write a slash (`/') after each filename if that file is a direc-
##              tory.
## 
##      --qq      Force printing of non-graphic characters in file names as the
##              character `?'; this is the default when output is to a terminal.
## 
##      --RR      Recursively list subdirectories encountered.
## 
##      --rr      Reverse the order of the sort to get reverse lexicographical
##              order or the oldest entries first (or largest files last, if com-
##              bined with sort by size
## 
##      --SS      Sort files by size
## 
##      --ss      Display the number of file system blocks actually used by each
##              file, in units of 512 bytes, where partial units are rounded up
##              to the next integer value.  If the output is to a terminal, a
##              total sum for all the file sizes is output on a line before the
##              listing.  The environment variable BLOCKSIZE overrides the unit
##              size of 512 bytes.
## 
##      --TT      When used with the --ll (lowercase letter ``ell'') option, display
##              complete time information for the file, including month, day,
##              hour, minute, second, and year.
## 
##      --tt      Sort by time modified (most recently modified first) before sort-
##              ing the operands by lexicographical order.
## 
##      --uu      Use time of last access, instead of last modification of the file
##              for sorting (--tt) or long printing (--ll).
## 
##      --UU      Use time of file creation, instead of last modification for sort-
##              ing (--tt) or long output (--ll).
## 
##      --vv      Force unedited printing of non-graphic characters; this is the
##              default when output is not to a terminal.
## 
##      --WW      Display whiteouts when scanning directories.  (--SS) flag).
## 
##      --ww      Force raw printing of non-printable characters.  This is the
##              default when output is not to a terminal.
## 
##      --xx      The same as --CC, except that the multi-column output is produced
##              with entries sorted across, rather than down, the columns.
## 
##      The --11, --CC, --xx, and --ll options all override each other; the last one
##      specified determines the format used.
## 
##      The --cc and --uu options override each other; the last one specified deter-
##      mines the file time used.
## 
##      The --BB, --bb, --ww, and --qq options all override each other; the last one
##      specified determines the format used for non-printable characters.
## 
##      The --HH, --LL and --PP options all override each other (either partially or
##      fully); they are applied in the order specified.
## 
##      By default, llss lists one entry per line to standard output; the excep-
##      tions are to terminals or when the --CC or --xx options are specified.
## 
##      File information is displayed with one or more &lt;blank&gt;s separating the
##      information associated with the --ii, --ss, and --ll options.
## 
##    TThhee LLoonngg FFoorrmmaatt
##      If the --ll option is given, the following information is displayed for
##      each file: file mode, number of links, owner name, group name, number of
##      bytes in the file, abbreviated month, day-of-month file was last modi-
##      fied, hour file last modified, minute file last modified, and the path-
##      name.  In addition, for each directory whose contents are displayed, the
##      total number of 512-byte blocks used by the files in the directory is
##      displayed on a line by itself, immediately before the information for the
##      files in the directory.  If the file or directory has extended
##      attributes, the permissions field printed by the --ll option is followed by
##      a '@' character.  Otherwise, if the file or directory has extended secu-
##      rity information (such as an access control list), the permissions field
##      printed by the --ll option is followed by a '+' character.
## 
##      If the modification time of the file is more than 6 months in the past or
##      future, then the year of the last modification is displayed in place of
##      the hour and minute fields.
## 
##      If the owner or group names are not a known user or group name, or the --nn
##      option is given, the numeric ID's are displayed.
## 
##      If the file is a character special or block special file, the major and
##      minor device numbers for the file are displayed in the size field.  If
##      the file is a symbolic link, the pathname of the linked-to file is pre-
##      ceded by ``-&gt;''.
## 
##      The file mode printed under the --ll option consists of the entry type,
##      owner permissions, and group permissions.  The entry type character
##      describes the type of file, as follows:
## 
##            bb     Block special file.
##            cc     Character special file.
##            dd     Directory.
##            ll     Symbolic link.
##            ss     Socket link.
##            pp     FIFO.
##            --     Regular file.
## 
##      The next three fields are three characters each: owner permissions, group
##      permissions, and other permissions.  Each field has three character posi-
##      tions:
## 
##            1.   If rr, the file is readable; if --, it is not readable.
## 
##            2.   If ww, the file is writable; if --, it is not writable.
## 
##            3.   The first of the following that applies:
## 
##                       SS     If in the owner permissions, the file is not exe-
##                             cutable and set-user-ID mode is set.  If in the
##                             group permissions, the file is not executable and
##                             set-group-ID mode is set.
## 
##                       ss     If in the owner permissions, the file is exe-
##                             cutable and set-user-ID mode is set.  If in the
##                             group permissions, the file is executable and set-
##                             group-ID mode is set.
## 
##                       xx     The file is executable or the directory is search-
##                             able.
## 
##                       --     The file is neither readable, writable, exe-
##                             cutable, nor set-user-ID nor set-group-ID mode,
##                             nor sticky.  (See below.)
## 
##                 These next two apply only to the third character in the last
##                 group (other permissions).
## 
##                       TT     The sticky bit is set (mode 1000), but not execute
##                             or search permission.  (See chmod(1) or
##                             sticky(8).)
## 
##                       tt     The sticky bit is set (mode 1000), and is search-
##                             able or executable.  (See chmod(1) or sticky(8).)
## 
## EEXXAAMMPPLLEESS
##      The following is how to do an llss listing sorted by increasing size
## 
##            ls -lrS
## 
## DDIIAAGGNNOOSSTTIICCSS
##      The llss utility exits 0 on success, and &gt;0 if an error occurs.
## 
## EENNVVIIRROONNMMEENNTT
##      The following environment variables affect the execution of llss:
## 
##      BLOCKSIZE       If the environment variable BLOCKSIZE is set, the block
##                      counts (see --ss) will be displayed in units of that size
##                      block.
## 
##      CLICOLOR        Use ANSI color sequences to distinguish file types.  See
##                      LSCOLORS below.  In addition to the file types mentioned
##                      in the --FF option some extra attributes (setuid bit set,
##                      etc.) are also displayed.  The colorization is dependent
##                      on a terminal type with the proper termcap(5) capabili-
##                      ties.  The default ``cons25'' console has the proper
##                      capabilities, but to display the colors in an xterm(1),
##                      for example, the TERM variable must be set to
##                      ``xterm-color''.  Other terminal types may require simi-
##                      lar adjustments.  Colorization is silently disabled if
##                      the output isn't directed to a terminal unless the
##                      CLICOLOR_FORCE variable is defined.
## 
##      CLICOLOR_FORCE  Color sequences are normally disabled if the output isn't
##                      directed to a terminal.  This can be overridden by set-
##                      ting this flag.  The TERM variable still needs to refer-
##                      ence a color capable terminal however otherwise it is not
##                      possible to determine which color sequences to use.
## 
##      COLUMNS         If this variable contains a string representing a decimal
##                      integer, it is used as the column position width for dis-
##                      playing multiple-text-column output.  The llss utility cal-
##                      culates how many pathname text columns to display based
##                      on the width provided.  (See --CC and --xx.)
## 
##      LANG            The locale to use when determining the order of day and
##                      month in the long --ll format output.  See environ(7) for
##                      more information.
## 
##      LSCOLORS        The value of this variable describes what color to use
##                      for which attribute when colors are enabled with
##                      CLICOLOR.  This string is a concatenation of pairs of the
##                      format _f_b, where _f is the foreground color and _b is the
##                      background color.
## 
##                      The color designators are as follows:
## 
##                            aa     black
##                            bb     red
##                            cc     green
##                            dd     brown
##                            ee     blue
##                            ff     magenta
##                            gg     cyan
##                            hh     light grey
##                            AA     bold black, usually shows up as dark grey
##                            BB     bold red
##                            CC     bold green
##                            DD     bold brown, usually shows up as yellow
##                            EE     bold blue
##                            FF     bold magenta
##                            GG     bold cyan
##                            HH     bold light grey; looks like bright white
##                            xx     default foreground or background
## 
##                      Note that the above are standard ANSI colors.  The actual
##                      display may differ depending on the color capabilities of
##                      the terminal in use.
## 
##                      The order of the attributes are as follows:
## 
##                            1.   directory
##                            2.   symbolic link
##                            3.   socket
##                            4.   pipe
##                            5.   executable
##                            6.   block special
##                            7.   character special
##                            8.   executable with setuid bit set
##                            9.   executable with setgid bit set
##                            10.  directory writable to others, with sticky bit
##                            11.  directory writable to others, without sticky
##                                 bit
## 
##                      The default is "exfxcxdxbxegedabagacad", i.e. blue fore-
##                      ground and default background for regular directories,
##                      black foreground and red background for setuid executa-
##                      bles, etc.
## 
##      LS_COLWIDTHS    If this variable is set, it is considered to be a colon-
##                      delimited list of minimum column widths.  Unreasonable
##                      and insufficient widths are ignored (thus zero signifies
##                      a dynamically sized column).  Not all columns have
##                      changeable widths.  The fields are, in order: inode,
##                      block count, number of links, user name, group name,
##                      flags, file size, file name.
## 
##      TERM            The CLICOLOR functionality depends on a terminal type
##                      with color capabilities.
## 
##      TZ              The timezone to use when displaying dates.  See
##                      environ(7) for more information.
## 
## CCOOMMPPAATTIIBBIILLIITTYY
##      The group field is now automatically included in the long listing for
##      files in order to be compatible with the IEEE Std 1003.2 (``POSIX.2'')
##      specification.
## 
## LLEEGGAACCYY DDEESSCCRRIIPPTTIIOONN
##      In legacy mode, the --ff option does not turn on the --aa option and the --gg,
##      --nn, and --oo options do not turn on the --ll option.
## 
##      Also, the --oo option causes the file flags to be included in a long (-l)
##      output; there is no --OO option.
## 
##      When --HH is specified (and not overridden by --LL or --PP) and a file argument
##      is a symlink that resolves to a non-directory file, the output will
##      reflect the nature of the link, rather than that of the file.  In legacy
##      operation, the output will describe the file.
## 
##      For more information about legacy mode, see compat(5).
## 
## SSEEEE AALLSSOO
##      chflags(1), chmod(1), sort(1), xterm(1), compat(5), termcap(5),
##      symlink(7), sticky(8)
## 
## SSTTAANNDDAARRDDSS
##      The llss utility conforms to IEEE Std 1003.1-2001 (``POSIX.1'').
## 
## HHIISSTTOORRYY
##      An llss command appeared in Version 1 AT&amp;T UNIX.
## 
## BBUUGGSS
##      To maintain backward compatibility, the relationships between the many
##      options are quite complex.
## 
## BSD                              May 19, 2002                              BSD
```

---

# Shell basics

Pressing `h` within a man page brings up the help page for how to navigate them

`/terms_here` lets you search within the man page for particular terms

Use `n` and `shift+n` to move forward and backward between matches

---

# Navigation

We already learned how to list the files in a particular directory, but we need a few other tools to navigate around our machine

--

We often will want to know our .hi-blue[current working directory] so we know where we are before we start running commands

We do this with `pwd`


```bash
$ pwd
```

```
## /Users/ir229/Desktop/git/aem7130/spring-2020/lecture_notes/lecture_2
```

---

# Navigation

Directories are organized in a hierarchical structure, at the top is the root directory, `/`


```bash
$ ls /
```

```
## Applications
## Library
## Network
## System
## Users
## Volumes
## anaconda3
## bin
## cores
## dev
## etc
## home
## installer.failurerequests
## net
## opt
## private
## sbin
## tmp
## usr
## var
```


---

# Navigation

The root directory contains everything else

Other directories are inside the root directory and come afterward in the file path separated by forward slashes `/`


```bash
$ ls -lSh /Users
```

```
## total 0
## drwxr-xr-x+ 79 ir229          staff      2.5K Jan 26 12:52 ir229
## drwxr-xr-x+ 15 ag-wt94-doc10  11103514   480B Jan 10  2018 ag-wt94-doc10
## drwxr-xr-x+ 12 Guest          _guest     384B Nov 27  2017 Guest
## drwxr-xr-x  11 cals_oit       staff      352B Jan  9  2018 cals_oit
## drwxrwxrwt   7 root           wheel      224B Jun 28  2019 Shared
## drwxr-xr-x   5 ir229          admin      160B Dec 16  2018 ivan
## drwxr-xr-x   3 root           staff       96B Nov 17  2017 root
```

---

# Navigation

The root directory contains everything else

Other directories are inside the root directory and come afterward in the file path separated by forward slashes `/`


```bash
$ ls -lSh /Users/ir229
```

```
## total 8
## drwx------+ 829 ir229  staff    26K Jan 26 15:01 Downloads
## drwx------+  71 ir229  staff   2.2K Sep 23 18:25 Library
## -rw-r--r--@   1 ir229  staff   1.0K Nov 25 13:39 artelys_lic_trial_artelys_knitro_academic_bb-8b-8e-28-3d.txt
## drwx------@  24 ir229  staff   768B Jan 21 17:03 Dropbox
## drwxr-xr-x   21 ir229  staff   672B Jan 17  2019 reveal.js
## drwx------+   8 ir229  staff   256B Feb  7  2019 Documents
## drwx------+   7 ir229  staff   224B Jan 23 11:37 Desktop
## drwxr-xr-x    7 ir229  staff   224B Jan 26 12:49 HEG
## drwxr-xr-x    7 ir229  staff   224B Jan 26 12:50 wekafiles
## drwx------+   4 ir229  staff   128B Dec 21  2017 Music
## drwxr-xr-x+   4 ir229  staff   128B Nov 17  2017 Public
## drwx------@   3 ir229  staff    96B Nov 24  2017 Applications
## drwx------@   3 ir229  staff    96B Apr 10  2019 Google Drive
## drwx------+   3 ir229  staff    96B Nov 17  2017 Movies
## drwx------+   3 ir229  staff    96B Dec 21  2017 Pictures
## drwx------    2 ir229  staff    64B Jan 29  2018 Box Sync
```

---

# Navigation

Next we need to be able to change directories, we can do this with `cd`


```bash
$ cd /Users/ir229/Desktop/git
$ pwd
```

```
## /Users/ir229/Desktop/git
```

--

When navigating, it is often easier and more reproducible to use .hi-blue[relative paths]

--

This is when arguments are relative to your current working directory, instead of using absolute paths (e.g. /Users/ir229/Desktop/git)

---

# Navigation

There's a few expressions that make this possible

- `~` is your .hi-blue[home directory]
- `.` is your current directory
- `..` is the parent directory
- `-` is the previous directory you were in

---

# Navigation


```bash
$ cd ~ # move to home directory (will vary computer-to-computer)
$ pwd
$ cd - # move to previous directory (lecture notes 2 directory)
$ cd .. # move to parent directory (general lecture notes directory)
$ pwd
$ cd . # move to current directory (nothing changes)
$ pwd
```

```
## /Users/ir229
## /Users/ir229/Desktop/git/aem7130/spring-2020/lecture_notes/lecture_2
## /Users/ir229/Desktop/git/aem7130/spring-2020/lecture_notes
## /Users/ir229/Desktop/git/aem7130/spring-2020/lecture_notes
```

You can see `.` and `..` in your current directory when using `ls` with the `a` flag

```bash
$ ls -a
```

```
## .
## ..
## .DS_Store
## .Rhistory
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
```
---

# Navigation

This makes navigation much easier, if we wanted to move from the current directory to the parent directory for this year's course we can just do

```bash
$ pwd
$ cd ../..
$ pwd
```

```
## /Users/ir229/Desktop/git/aem7130/spring-2020/lecture_notes/lecture_2
## /Users/ir229/Desktop/git/aem7130/spring-2020
```
instead of

```bash
$ cd /Users/ir229/Desktop/git/aem7130/spring-2020
$ pwd
```

```
## /Users/ir229/Desktop/git/aem7130/spring-2020
```

---

# Creating files and directories

We learned how to move around directories but how do we make them?

We do so with `mkdir` (make directory)


```bash
$ mkdir test_directory
$ ls
```

```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_directory
```

---

# Creating files and directories

We create blank files using `touch`


```bash
$ touch test_directory/test.txt test_directory/test1.txt
$ ls test_directory
```

```
## test.txt
## test1.txt
```

`touch` is useful if you have a program that can't create a file itself but can edit them

---

# Creating files and directories

If you have a Unix system pre-installed with nano
you can use `nano` to create and edit the file

```bash
$ nano test_directory/test.txt
```

---

# Creating files and directories

Here are some tips for naming files and directories

1. .hi-red[DON'T USE SPACES]
    - Spaces are used to separate commands, you generally want to avoid them in names in favor of underscores or dashes
2. Use letters, numbers, underscores, periods, and dashes only

---

# Creating files and directories

If you really, really, want to use spaces in names you'll have to do one of two things, enclose in quotes or backslash the space


```bash
$ mkdir "123test directory"
$ ls
```

```
## 123test directory
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_directory
```


```bash
$ mkdir 123test\ directory\ 2
$ ls
```

```
## 123test directory
## 123test directory 2
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_directory
```


```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_directory
```

---

# Moving files and directories

We can move files and directories with `mv`, move


```bash
$ mv test_directory/test.txt ..
$ ls ..
```

```
## figures
## lecture_1
## lecture_2
## test.txt
```

The first argument is the (relative) path of the file you want to move, the second argument is where you're moving it to

We moved the test.txt file from  `test_directory` to the parent directory

---

# Moving files and directories


```bash
$ mv ../test.txt test_directory
$ ls test_directory
```

```
## test.txt
## test1.txt
```

Here we moved it from the parent directory back to `test_directory`

--

Note that `mv` will overwrite any file with the move, use the `-i` option to make it ask you for confirmation

---

# Moving files and directories

`mv` can also be used to rename files by just moving them to the same directory


```bash
$ mv test_directory/test.txt test_directory/test_new_name.txt
$ ls test_directory
```

```
## test1.txt
## test_new_name.txt
```

```bash
$ mv test_directory/test_new_name.txt test_directory/test.txt
$ ls test_directory
```

```
## test.txt
## test1.txt
```
---

# Moving files and directories

Now that we've made the directory and file, how do we get rid of them? With `rm`


```bash
$ rm test_directory/test.txt
$ ls
```

```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_directory
```

---

# Moving files and directories

We remove directories with `rmdir`


```bash
$ rmdir test_directory
$ ls
```

```
## rmdir: test_directory: Directory not empty
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_directory
```

Notice that if a directory isn't empty you can't delete it

---

# Moving files and directories

To delete a non-empty directory, you need to use `rm` but apply the recursive option `-r` to delete everything inside of it first


```bash
$ rm -r test_directory
$ ls
```

```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
```

Sometimes you might want to add the force option `-f` so it doesn't ask you if you want to delete each file

---

# Copying files and directories

To copy files and directories just use `cp`, it works similarly to `mv`


```bash
$ mkdir test_directory
$ touch test_directory/test_copy.txt
$ cp test_directory/test_copy.txt .
$ ls test_directory
```

```
## test_copy.txt
```

```bash
$ ls
```

```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_copy.txt
## test_directory
```



---

# Copying files and directories

You copy directories the same way, but if you want to copy the full file contents you need to apply the recursive option `-r`


```bash
$ cp -r test_directory ..
$ ls ..
```

```
## figures
## lecture_1
## lecture_2
## test_directory
```

```bash
$ ls
```

```
## 2a_coding.Rmd
## 2a_coding.html
## 2a_coding_files
## figures
## my-css.css
## sandbox
## test_directory
```


```
## figures
## lecture_1
## lecture_2
```

---

# Copying multiple files

How do we copy multiple files?

Let's make two directories for copying and a set of similar files


```bash
$ mkdir main_directory copy_directory
$ touch main_directory/file1.txt main_directory/file2.txt main_directory/file3.txt
$ ls main_directory
```

```
## file1.txt
## file2.txt
## file3.txt
```

---

# Copying multiple files

To copy them we can just use `cp` as we did before

```bash
$ cp main_directory/file1.txt main_directory/file2.txt main_directory/file3.txt copy_directory
$ ls copy_directory
```

```
## file1.txt
## file2.txt
## file3.txt
```


```bash
$ rm main_directory/file1.txt main_directory/file2.txt main_directory/file3.txt
```

Or we could use the `mv` rename trick into a new directory named `copy_directory`

---

# Renaming multiple files

We can rename multiple files in an easier way using `rename` (`brew install rename` to install using Homebrew)

We can change all of our txt files to csvs, `-s` indicates that the first argument is to be the text we are changing, and the second argument is the text we are changing it to, the third argument is the location of the files we are renaming


```bash
$ ls copy_directory
```

```
## file1.txt
## file2.txt
## file3.txt
```


```bash
$ rename -s .txt .csv copy_directory/*
$ ls copy_directory
```

```
## file1.csv
## file2.csv
## file3.csv
```

---

# Accessing multiple files

We can access multiple things at once using .hi-blue[wildcards] `*`, 
which replaces zero to any number of characters in the expression


```bash
$ touch copy_directory/test1.txt copy_directory/test2.txt copy_directory/test3.txt copy_directory/test123.txt
$ ls copy_directory/* # return everything in copy_directory
```

```
## copy_directory/file1.csv
## copy_directory/file2.csv
## copy_directory/file3.csv
## copy_directory/test1.txt
## copy_directory/test123.txt
## copy_directory/test2.txt
## copy_directory/test3.txt
```


```bash
$ ls copy_directory/*.csv # return everything in copy_directory with the csv extension
```

```
## copy_directory/file1.csv
## copy_directory/file2.csv
## copy_directory/file3.csv
```



---

# Word count

The shell really shines when you try to combine multiple commands into one

Lets play around with the `sandbox` directory and count the number of words in one of the files using `wc`


```bash
$ ls sandbox
$ wc sandbox/animals.txt
```

```
## animals.txt
## classes
## hey_jude.txt
## lucy_in_the_sky.txt
## trees.txt
##        0       7      33 sandbox/animals.txt
```

The first number is the number of lines, the second is the number of words, and the third is the number of characters

---

# Word count

We can run this using the wildcard for all text files and also get the totals


```bash
$ wc sandbox/*.txt
```

```
##        0       7      33 sandbox/animals.txt
##       29     195     979 sandbox/hey_jude.txt
##       45     220    1191 sandbox/lucy_in_the_sky.txt
##        0       8      46 sandbox/trees.txt
##       74     430    2249 total
```

---

# Redirecting

Now suppose we had 1 million files and wanted to find the one with the most words? Just printing to the screen doesn't work, we'd want to save the output and use it somewhere else, we can do that by .hi-blue[redirecting] with the greater than symbol `&gt;`


```bash
$ wc -m sandbox/*.txt &gt; sandbox/lengths.txt
$ ls sandbox
```

```
## animals.txt
## classes
## hey_jude.txt
## lengths.txt
## lucy_in_the_sky.txt
## trees.txt
```

---

# Printing and cating

We can print the file to the screen using `cat` (concatenate, print the full file) or `less` (print only one screenful)


```bash
$ cat sandbox/lengths.txt
```

```
##       33 sandbox/animals.txt
##      979 sandbox/hey_jude.txt
##     1191 sandbox/lucy_in_the_sky.txt
##       46 sandbox/trees.txt
##     2249 total
```


```bash
$ less sandbox/lengths.txt
```

```
##       33 sandbox/animals.txt
##      979 sandbox/hey_jude.txt
##     1191 sandbox/lucy_in_the_sky.txt
##       46 sandbox/trees.txt
##     2249 total
```

The `m` option made it so we only got the number of characters, not words or lines

---

# Sorting

If we want to return the output sorted we can use `sort`


```bash
$ sort -n sandbox/lengths.txt
```

```
##       33 sandbox/animals.txt
##       46 sandbox/trees.txt
##      979 sandbox/hey_jude.txt
##     1191 sandbox/lucy_in_the_sky.txt
##     2249 total
```

where the `n` option means to sort numerically

We can look at only the first few lines using `head`, (`tail` gets the last lines)


```bash
$ head -n 1 sandbox/lengths.txt
```

```
##       33 sandbox/animals.txt
```

Where the 1 means we only want the first line

---

# Redirecting

`&gt;` will always overwrite a file, we can use the double greater than symbol `&gt;&gt;` to append to a file

Lets use `echo` for an example which prints text


```bash
$ echo Hello world!
```

```
## Hello world!
```


```bash
$ echo \ walnut &gt;&gt; sandbox/trees.txt
$ cat sandbox/trees.txt
```

```
## maple pine birch oak beechnut palm fig redwood walnut
```

---

# Piping

We've learned a few options for manipulating text files, we can combine them in easy ways using .hi-blue[piping] (same idea as Julia's queryverse and R's tidyverse)

Pipes `|` allow you sequentially write out commands that use the previous command's output as the next command's input

Suppose we wanted to find the file in a directory with the most number of characters, we could do this with


```bash
$ wc -m sandbox/* | sort -n | tail -n 2
```

```
## wc: sandbox/classes: read: Is a directory
##     1191 sandbox/lucy_in_the_sky.txt
##     2395 total
```

The `length.txt` file is the longest in the sandbox directory

---

# Piping

Look at the file `sandbox/hey_jude.txt`, how would we get the second verse?

--

We can pipe a `head` and `tail` together:

```bash
$ head -n 9 sandbox/hey_jude.txt | tail -n 4
```

```
## Hey jude, don't be afraid.
## You were made to go out and get her.
## The minute you let her under your skin,
## Then you begin to make it better.
```

`head` grabs the first two verses (with the empty line inbetween), `tail` grabs second verse

---

# Looping example 1

What if we wanted the second verse of *multiple songs*?

We can do that with a loop


```bash
$ for thing in list
$ do
$     operation_using $thing    # Indentation is good style
$ done
```

`$` preprends any variables, here the variables are the things we're looping over

---

# Looping example 1


```bash
$ for song in sandbox/hey_jude.txt sandbox/lucy_in_the_sky.txt
$ do
$     head -n 9 $song | tail -n 4
$ done
```

```
## Hey jude, don't be afraid.
## You were made to go out and get her.
## The minute you let her under your skin,
## Then you begin to make it better.
## Cellophane flowers of yellow and green
## Towering over your head
## Look for the girl with the sun in her eyes
## And she's gone
```

---

# Looping example 2

How about a more realistic one that is real world useful (taken from [Grant Mcdermott](https://raw.githack.com/uo-ec607/lectures/master/03-shell/03-shell.html#109))

Let's combine a bunch of csvs using the shell

This is particularly useful with many or large datasets, because when done through shell, you do not need to load them into memory

The files are in `/sandbox/classes` and report a fake class schedule

Let's combine them into one

---

# Looping example 2

First we need to make our class schedule file

```bash
$ touch sandbox/classes/class_schedule.csv
```

--

Then we need to add each day's schedule to the file

```bash
$ for day in $(ls sandbox/classes/*day.csv)
$ do
$     cat $day &gt;&gt; sandbox/classes/class_schedule.csv
$ done
```

where we treat what `ls` returns as a variable since its the output of a command

---

# Looping example 2


```bash
$ cat sandbox/classes/class_schedule.csv
```

```
## day,morning,afternoon,evening
## friday,nothing,workshop,nothing
## monday,micro,macro,metrics
## thursday,game theory,seminar,nothings
## tuesday,game theory,seminar,nothings
## wednesday,micro,macro,metrics
## day,morning,afternoon,evening
## friday,nothing,workshop,nothing
## day,morning,afternoon,evening
## monday,micro,macro,metrics
## day,morning,afternoon,evening
## thursday,game theory,seminar,nothings
## day,morning,afternoon,evening
## tuesday,game theory,seminar,nothings
## day,morning,afternoon,evening
## wednesday,micro,macro,metrics
```

Looks like it worked but we have the header, how do we get rid of it?

.hi-blue[Hint:] we only need the header once, and then we want the last line of the csv for each file

---

# Looping example 2

First lets remove the old file

```bash
$ rm -f sandbox/classes/class_schedule.csv
```

Next create the new file by grabbing the header from Monday


```bash
$ head -1 sandbox/classes/monday.csv &gt; sandbox/classes/class_schedule.csv
$ cat sandbox/classes/class_schedule.csv
```

```
## day,morning,afternoon,evening
```

---

# Looping example 2

So we've got the file started, now we need to fill in the days using our looping skills

Then we need to add each day's schedule to the file

```bash
$ for day in $(ls sandbox/classes/*day.csv)
$ do
$     tail -1 $day | cat &gt;&gt; sandbox/classes/class_schedule.csv
$ done
$ cat sandbox/classes/class_schedule.csv
```

```
## day,morning,afternoon,evening
## friday,nothing,workshop,nothing
## monday,micro,macro,metrics
## thursday,game theory,seminar,nothings
## tuesday,game theory,seminar,nothings
## wednesday,micro,macro,metrics
```

---

# Finding things

How can we find things within files?

We use the command `grep` (global/regular expression/print)

`grep` finds and prints lines that match a certain pattern

For example, lets find the lines in Hey Jude that contain "make"


```bash
$ grep make sandbox/hey_jude.txt
```

```
## Hey jude, don't make it bad.
## Take a sad song and make it better.
## Then you can start to make it better.
## Then you begin to make it better.
## Then you can start to make it better.
## Hey jude, don't make it bad.
## Take a sad song and make it better.
## Then you'll begin to make it
```

---

# Finding things


```bash
$ grep make sandbox/hey_jude.txt
```

Here `make` is the pattern we are searching for inside Hey Jude


---

# Finding things

Now lets search Lucy in the Sky for "in"


```bash
$ grep in sandbox/lucy_in_the_sky.txt | head -5
```

```
## Picture yourself in a boat on a river
## With tangerine trees and marmalade skies
## Towering over your head
## Look for the girl with the sun in her eyes
## Lucy in the sky with diamonds
```

This gave us words that contained "in" but weren't actually the word "in"

---

# Finding things

We can restrict the search to words with the `w` option


```bash
$ grep -w in sandbox/lucy_in_the_sky.txt | head -5
```

```
## Picture yourself in a boat on a river
## Look for the girl with the sun in her eyes
## Lucy in the sky with diamonds
## Lucy in the sky with diamonds
## Lucy in the sky with diamonds
```

---

# Grepping

`grep`s real power comes from using .hi-blue[regular expressions]

These are complex expressions that allow you to search for very specific things

For example, lets find lines with "a" as the second letter


```bash
$ grep -E "^.a" sandbox/lucy_in_the_sky.txt | head -5
```

```
## Waiting to take you away
```

`grep` shows up in most programming languages as well

You can imagine using it to do things like dynamically renaming a set of variables, dealing with weirdly reported FIPS codes, etc

---

# Shell scripts

A nice thing about shell that's pretty underused by economists is putting the commands into scripts so we can re-use them


```bash
$ # writing a shell script using echo is kind of silly
$ # but I want to show you what I'm doing on the slides
$ touch sandbox/shell_script.sh
$ echo echo "Hello World!" &gt;&gt; sandbox/shell_script.sh 
$ cat sandbox/shell_script.sh
```

```
## echo Hello World!
```

We can the execute it using bash

```bash
$ bash sandbox/shell_script.sh
```

```
## Hello World!
```



&lt;!-- --- --&gt;

&lt;!-- # Why am I doing this to you? --&gt;

&lt;!-- Why learn shell and Julia? --&gt;

&lt;!-- 1. It's a high-level language, much easier to use than C++, Fortran, etc --&gt;
&lt;!-- 2. It delivers speeds in the ballpark of C++ and Fortran even with the super old 0.2 version --&gt;

&lt;!-- &lt;div align="center"&gt; --&gt;
&lt;!--   &lt;img src="/figures/julia_speed_2.png" height=350&gt; --&gt;
&lt;!-- &lt;/div&gt; --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Intro to programming --&gt;

&lt;!-- ### Programming `\(\equiv\)` writing a set of instructions --&gt;

&lt;!-- 1. There are hard and fast rules you can't break if you want it to work --&gt;
&lt;!-- 2. There are elements of style (e.g. Strunk and White) that make for clearer and more efficient code --&gt;


&lt;!-- -- --&gt;

&lt;!-- If you will be doing computational work there are: --&gt;

&lt;!-- 1. Language-independent coding basics you should know --&gt;
&lt;!--   - Arrays are stored in memory in particular ways   --&gt;
&lt;!-- -- --&gt;

&lt;!-- 2. Language-independent best practices you should use --&gt;
&lt;!--   - Indent to convey program structure (or function in Python)    --&gt;
&lt;!-- -- --&gt;

&lt;!-- 3. Language-dependent idiosyncracies that matter for function, speed, memory allocation, etc --&gt;
&lt;!--   - MATLAB: vectorize, vectorize, vectorize --&gt;
&lt;!--   - Julia: loops forever --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Intro to programming --&gt;

&lt;!-- ### Learning these early will: --&gt;

&lt;!-- 1. Make coding a lot easier --&gt;
&lt;!-- -- --&gt;

&lt;!-- 2. Reduce total programmer time --&gt;
&lt;!-- -- --&gt;

&lt;!-- 3. Reduce total computer time --&gt;
&lt;!-- -- --&gt;

&lt;!-- 4. Make your code understandable by someone else or your future self --&gt;
&lt;!-- -- --&gt;

&lt;!-- 5. Make your code flexible --&gt;

&lt;!-- --- --&gt;

&lt;!-- # A broad view of programming --&gt;

&lt;!-- Your goal is to make a **program** --&gt;

&lt;!-- A program is made of different components and sub-components --&gt;

&lt;!-- -- --&gt;

&lt;!-- The most basic component is a **statement**, more commonly called a **line of code** --&gt;

&lt;!-- -- --&gt;

&lt;!-- Here's pseudoprogram:   --&gt;
&lt;!-- ```julia --&gt;
&lt;!-- deck = ["4 of hearts", "King of clubs", "Ace of spades"] --&gt;
&lt;!-- shuffled_deck = shuffle(deck) --&gt;
&lt;!-- first_card = shuffled_deck[1] --&gt;
&lt;!-- println("The first drawn card was " * shuffled_deck ".") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This program is real simple: --&gt;

&lt;!-- --- --&gt;

&lt;!-- # A broad view of programming --&gt;

&lt;!-- Your goal is to make a **program** --&gt;

&lt;!-- A program is made of different components and sub-components --&gt;

&lt;!-- The most basic component is a **statement**, more commonly called a **line of code** --&gt;

&lt;!-- Here's pseudoprogram:   --&gt;
&lt;!-- ```julia --&gt;
&lt;!-- *deck = ["4 of hearts", "King of clubs", "Ace of spades"] --&gt;
&lt;!-- shuffled_deck = shuffle(deck) --&gt;
&lt;!-- first_card = shuffled_deck[1] --&gt;
&lt;!-- println("The first drawn card was " * shuffled_deck ".") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This program is real simple: --&gt;

&lt;!-- 1. Create a deck of cards --&gt;

&lt;!-- --- --&gt;

&lt;!-- # A broad view of programming --&gt;

&lt;!-- Your goal is to make a **program** --&gt;

&lt;!-- A program is made of different components and sub-components --&gt;

&lt;!-- The most basic component is a **statement**, more commonly called a **line of code** --&gt;

&lt;!-- Here's pseudoprogram:   --&gt;
&lt;!-- ```julia --&gt;
&lt;!-- deck = ["4 of hearts", "King of clubs", "Ace of spades"] --&gt;
&lt;!-- *shuffled_deck = shuffle(deck) --&gt;
&lt;!-- first_card = shuffled_deck[1] --&gt;
&lt;!-- println("The first drawn card was " * shuffled_deck ".") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This program is real simple: --&gt;

&lt;!-- 1. Create a deck of cards --&gt;
&lt;!-- 2. Shuffle the deck --&gt;

&lt;!-- --- --&gt;

&lt;!-- # A broad view of programming --&gt;

&lt;!-- Your goal is to make a **program** --&gt;

&lt;!-- A program is made of different components and sub-components --&gt;

&lt;!-- The most basic component is a **statement**, more commonly called a **line of code** --&gt;

&lt;!-- Here's pseudoprogram:   --&gt;
&lt;!-- ```julia --&gt;
&lt;!-- deck = ["4 of hearts", "King of clubs", "Ace of spades"] --&gt;
&lt;!-- shuffled_deck = shuffle(deck) --&gt;
&lt;!-- *first_card = shuffled_deck[1] --&gt;
&lt;!-- println("The first drawn card was " * shuffled_deck ".") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This program is real simple: --&gt;

&lt;!-- 1. Create a deck of cards --&gt;
&lt;!-- 2. Shuffle the deck --&gt;
&lt;!-- 3. Draw the top card --&gt;

&lt;!-- --- --&gt;

&lt;!-- # A broad view of programming --&gt;

&lt;!-- Your goal is to make a **program** --&gt;

&lt;!-- A program is made of different components and sub-components --&gt;

&lt;!-- The most basic component is a **statement**, more commonly called a **line of code** --&gt;

&lt;!-- Here's pseudoprogram:   --&gt;
&lt;!-- ```julia --&gt;
&lt;!-- deck = ["4 of hearts", "King of clubs", "Ace of spades"] --&gt;
&lt;!-- shuffled_deck = shuffle(deck) --&gt;
&lt;!-- first_card = shuffled_deck[1] --&gt;
&lt;!-- *println("The first drawn card was " * shuffled_deck ".") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This program is real simple: --&gt;

&lt;!-- 1. Create a deck of cards --&gt;
&lt;!-- 2. Shuffle the deck --&gt;
&lt;!-- 3. Draw the top card --&gt;
&lt;!-- 4. Print it --&gt;

&lt;!-- --- --&gt;

&lt;!-- # A broad view of programming   --&gt;
&lt;!-- ```julia --&gt;
&lt;!-- deck = ["4 of hearts", "King of clubs", "Ace of spades"] --&gt;
&lt;!-- shuffled_deck = shuffle(deck) --&gt;
&lt;!-- first_card = shuffled_deck[1] --&gt;
&lt;!-- println("The first drawn card was " * shuffled_deck ".") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- What are the parentheses and why are they different from square brackets? --&gt;

&lt;!-- How does shuffle work?  --&gt;

&lt;!-- What’s println?  --&gt;

&lt;!-- It’s important to know that a good program has understandable code --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Julia specifics --&gt;

&lt;!-- We will discuss coding in the context of Julia but a lot of this ports to Python, MATLAB, etc --&gt;

&lt;!-- To do: --&gt;

&lt;!-- 1. Types --&gt;
&lt;!-- 2. Operators --&gt;
&lt;!-- 3. Scope --&gt;
&lt;!-- 4. Generic functions --&gt;
&lt;!-- 5. Multiple dispatch --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Types --&gt;

&lt;!-- All languages have some kind of **data types** like integers or arrays --&gt;

&lt;!-- The first type you will often use is a boolean (`Bool`) variable that takes on a value of `true` or `false`: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- x = true --&gt;
&lt;!-- typeof(x) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- Note that lines starting with `##` are code output --&gt;

&lt;!-- -- --&gt;

&lt;!-- We can save the boolean value of actual statements in variables this way: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- @show y = 1 &gt; 2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `@show` is a Julia macro for showing the operation --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Numbers --&gt;

&lt;!-- Two other data types you will use frequently are integers --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- typeof(1) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- and floating point numbers --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- typeof(1.0) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- Recall from last week the 64 means 64 bits of storage for the number, which is probably the default on your machine --&gt;

&lt;!-- -- --&gt;

&lt;!-- But you can always instantiate alternative floating point number types --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- converted_int = convert(Float32, 1.0); --&gt;
&lt;!-- typeof(converted_int) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Numbers --&gt;

&lt;!-- ### Math works like you would expect: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- a = 2; b = 1.0; --&gt;
&lt;!-- a * b --&gt;
&lt;!-- ``` --&gt;
&lt;!-- -- --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- a^2 --&gt;
&lt;!-- ``` --&gt;
&lt;!-- -- --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- 2a - 4b --&gt;
&lt;!-- ``` --&gt;
&lt;!-- -- --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- @show 4a + 3b^2 --&gt;
&lt;!-- ``` --&gt;
&lt;!-- -- --&gt;
&lt;!-- You dont need `*` inbetween numeric literals (numbers) and variables --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Strings --&gt;

&lt;!-- Strings store sequences of characters --&gt;

&lt;!-- You implement them with double quotations: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x = "Hello World!"; --&gt;
&lt;!-- typeof(x) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Note that `;` suppresses output for that line of code but is unnecessary --&gt;

&lt;!-- -- --&gt;

&lt;!-- It's easy to work with strings, use `$` to interpolate a variable/expression --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- x = 10; y = 20; println("x + y =  $(x+y).") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- Use `*` to concatenate strings --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- a = "Aww"; b = "Yeah!!!"; println(a * " " * b) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- You probably won't use strings too often unless you're working with data or printing output --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Containers are types that store collections of data --&gt;

&lt;!-- -- --&gt;

&lt;!-- The most basic container is the `Array` which is denoted by square brackets --&gt;

&lt;!-- -- --&gt;


&lt;!-- ```{julia} --&gt;
&lt;!-- a1 = [1 2; 3 4]; typeof(a1) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- `a1` is a two-dimensional `Array` of `Int64`s --&gt;

&lt;!-- -- --&gt;

&lt;!-- Arrays are **mutable** which means you can change their values --&gt;

&lt;!-- -- --&gt;


&lt;!-- ```{julia} --&gt;
&lt;!-- a1[1,1] = 5; a1 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- You reference elements in a container with square brackets --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- An alternative to the `Array` is the `Tuple` which is denoted by parentheses --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a2 = (1, 2, 3, 4); typeof(a2) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- `a2` is a `Tuple` of 4 `Int64`s, tuples have no dimension --&gt;

&lt;!-- -- --&gt;

&lt;!-- Tuples are **immutable** which means you **can't** change their values --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- try --&gt;
&lt;!--   a2[1,1] = 5; --&gt;
&lt;!-- catch --&gt;
&lt;!--   println("Error, can't change value of a tuple.") --&gt;
&lt;!--   a2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Tuples don't need parentheses (but it's probably best practice for clarity) --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- a3 = 5, 6; typeof(a3) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- And they can be **unpacked** (see [`NamedTuple`](https://docs.julialang.org/en/v1/manual/types/index.html#Parametric-Types-1) for an alternative and more efficient container) --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a3_x, a3_y = a3; --&gt;
&lt;!-- a3_x --&gt;
&lt;!-- a3_y --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This is basically how functions return output when you call them --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- A `Dictionary` is the last main container type, they are arrays but are indexed by keys (names) instead of numbers --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- d1 = Dict("class" =&gt; "AEM7130", "grade" =&gt; 97);  --&gt;
&lt;!-- typeof(d1) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- `d1` is a dictionary where the key are strings and the values are any kind of type --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Containers --&gt;

&lt;!-- Reference specific values you want in the dictionary by referencing the key --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- d1["class"] --&gt;
&lt;!-- d1["grade"] --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- If you just want all the keys or all the values you can use the base functions --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- keys_d1 = keys(d1) --&gt;
&lt;!-- values_d1 = values(d1) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- As in other languages we have loops at our disposal: --&gt;

&lt;!-- `for` loops iterate over containers --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- for count in 1:10 --&gt;
&lt;!--   random_number = rand() --&gt;
&lt;!--   if random_number &gt; 0.5 --&gt;
&lt;!--     println("We drew a $random_number.") --&gt;
&lt;!--   end --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- `while` loops iterate until a logical expression is false  --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- while rand() &gt; 0.5 --&gt;
&lt;!--   random_number = rand() --&gt;
&lt;!--   if random_number &gt; 0.5 --&gt;
&lt;!--     println("We drew a $random_number.") --&gt;
&lt;!--   end --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- An `Iterable` is something you can loop over, like arrays --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- actions = ["codes well", "skips class"]; --&gt;
&lt;!-- for action in actions --&gt;
&lt;!--     println("Charlie $action") --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- But there's a type that's a subset of iterables: `Iterator` --&gt;

&lt;!-- -- --&gt;

&lt;!-- These include things like the dictionary keys: --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- for key in keys_d1 --&gt;
&lt;!--   println(d1[key]) --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Iterating --&gt;

&lt;!-- Iterating on iterators is more memory efficient than iterating on arrays --&gt;

&lt;!-- -- --&gt;

&lt;!-- Here's a **very** simple example (the `global` isn't great style but ignore that; advanced tip: fix it with a wrapper function): --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- j = 1; --&gt;
&lt;!-- @time for i = [1, 2, 3, 4, 5, 6] --&gt;
&lt;!--   global j *= i --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- m = 1; --&gt;
&lt;!-- @time for i = 1:6 --&gt;
&lt;!--   global m *= i --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- `@time` is a macro that shows you the elasped time, memory allocation, and number of allocations (also garbage collection) --&gt;

&lt;!-- -- --&gt;

&lt;!-- Minimizing allocations and garbage collection will make your code faster (see `@profile`) --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- The nice thing about Julia vs MATLAB is your loops can be much neater since you don't need to index if you just want the container elements --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- f(x) = x^2; --&gt;
&lt;!-- x_values = 0:20:100; --&gt;
&lt;!-- for x in x_values --&gt;
&lt;!--   println(f(x)) --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- The loop directly assigns the elements of `x_values` to `x` instead of having to do something clumsy like `x_values[i]` --&gt;

&lt;!-- -- --&gt;

&lt;!-- `0:20:100` creates something called a `StepRange` which starts at `0`, steps up by `20` and ends at `100` --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- You can also pull out an index and the element value by enumerating --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- f(x) = x^2; --&gt;
&lt;!-- x_values = 0:20:100; --&gt;
&lt;!-- for (index, x) in enumerate(x_values) --&gt;
&lt;!--   println("f(x) at value $index is $(f(x)).") --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `enumerate` basically assigns an index vector --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- There is also a lot of Python-esque functionality --&gt;

&lt;!-- -- --&gt;

&lt;!-- For example: `zip` lets you loop over multiple different iterables at once --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- last_name = ("Lincoln", "Bond", "Walras"); --&gt;
&lt;!-- first_name = ("Abraham", "James", "Leon"); --&gt;

&lt;!-- for (first_idx, last_idx) in zip(first_name, last_name) --&gt;
&lt;!--   println("The name's $last_idx, $first_idx $last_idx.") --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Neat looping --&gt;

&lt;!-- Nested loops can also be made very neatly --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- for x in 1:3, y in 3:-1:1 --&gt;
&lt;!--   println(y-x) --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- The first loop is the inner loop, the second loop is the outer loop --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Comprehensions: the neatest looping --&gt;

&lt;!-- Comprehensions are super nice ways to use iterables that make your code cleaner and more compact --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- squared = [y^2 for y in 1:2:11] --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This created a 1-dimension `Array` using one line --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Comprehensions: the neatest looping --&gt;

&lt;!-- We can also use nested loops for comprehensions --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- squared_2 = [(y+z)^2 for y in 1:2:11, z in 1:6] --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This created a 2-dimensional `Array` --&gt;

&lt;!-- -- --&gt;

&lt;!-- Use this (and the compact nested loop) sparingly since it's hard to follow --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Dot syntax: vectorization --&gt;

&lt;!-- Vectorizing operations (e.g. applying it to a whole array or vector at once) is easy in Julia, just use dot syntax like you would in MATLAB, etc --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- g(x) = x^2; --&gt;
&lt;!-- squared_2 = g.(1:2:11) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This is actually called **broadcasting** --&gt;

&lt;!-- -- --&gt;

&lt;!-- When broadcasting, you might want to consider **pre-allocating** arrays --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Dot syntax: vectorization --&gt;

&lt;!-- Not pre-allocated: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- h(y,z) = y^2 + sin(z);   # function to evaluate --&gt;
&lt;!-- y = 1:2:1e6+1;           # input y --&gt;
&lt;!-- z = rand(length(y));     # input z --&gt;
&lt;!-- out_1 = h.(y,z);         # pre-evaluate h.(y,z) --&gt;
&lt;!-- @time out_1 = h.(y,z)    # evaluate h.(y,z) and time --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Dot syntax: vectorization --&gt;

&lt;!-- Pre-allocated, clumsy dot syntax where `.=` assigns elements in a vectorized fashion: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- out_2 = similar(y); --&gt;
&lt;!-- out_2 .= h.(y,z); --&gt;
&lt;!-- @time out_2 .= h.(y,z) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Dot syntax: vectorization --&gt;

&lt;!-- Pre-allocated, galaxy brain dot syntax: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- out_3 = similar(y); --&gt;
&lt;!-- @. out_3 = h(y,z); --&gt;
&lt;!-- @time @. out_3 = h(y,z) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Logical operators --&gt;

&lt;!-- Logical operators work like every other language  --&gt;

&lt;!-- -- --&gt;

&lt;!-- - `==` tests for equality --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- 1 == 1 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- - `!=` tests for inequality --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- 2 != 2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- - You can also test for approximate equality with `\(\approx\)` (type `\approx&lt;TAB&gt;`) --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- 1.00000001 ≈ 1 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Scope --&gt;

&lt;!-- **Scope** can be a frustrating concept if you haven't used a similarly scoped language before (and why I used that `global` indicator before) --&gt;

&lt;!-- -- --&gt;

&lt;!-- The scope of a variable name determines when it is valid to refer to it --&gt;

&lt;!-- -- --&gt;

&lt;!-- If you want to dive into the details: the type of scoping in Julia is called **lexical scoping** --&gt;

&lt;!-- -- --&gt;

&lt;!-- Different scopes can have the same name, i.e. `saving_rate`, but be assigned to different variables --&gt;

&lt;!-- -- --&gt;

&lt;!-- Let's walk through some simple examples to see how it works --&gt;

&lt;!-- -- --&gt;

&lt;!-- First, functions have their own local scope --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- ff(xx) = xx^2; --&gt;
&lt;!-- yy = 5; --&gt;
&lt;!-- ff(yy) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `xx` isn't bound to any values outside the function `ff` --&gt;

&lt;!-- --- --&gt;
&lt;!-- # Scope --&gt;

&lt;!-- This allows us to do things like: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- xx = 10; --&gt;
&lt;!-- fff(xx) = xx^2; --&gt;
&lt;!-- fff(5) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Although `xx` was declared equal to 10, the function still evaluated at 5 --&gt;

&lt;!-- -- --&gt;

&lt;!-- This is all kind of obvious so far --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- But, this type of scoping also has (initially) counterintuitive results like: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- zz = 0; --&gt;
&lt;!-- for ii = 1:10 --&gt;
&lt;!--   zz = ii --&gt;
&lt;!-- end --&gt;
&lt;!-- println("zz = $zz") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- What happened? --&gt;

&lt;!-- -- --&gt;

&lt;!-- The `zz` outside the for loop has a different scope, the **global scope**, than the `zz` inside it --&gt;

&lt;!-- -- --&gt;

&lt;!-- The `zz` inside the for loop has a scope local to the loop --&gt;

&lt;!-- -- --&gt;

&lt;!-- Since the outside `zz` has global scope the loop can't change it without the `global` indicator like we saw earlier  --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Generally you want to avoid `global` because it can cause conflicts, slowness, etc, but you can use them if you want something to have global scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- zz = 0; --&gt;
&lt;!-- for ii = 1:10 --&gt;
&lt;!--   global zz --&gt;
&lt;!--   zz = ii --&gt;
&lt;!-- end --&gt;
&lt;!-- println("zz = $zz") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Local scope kicks in whenever you have a new block keyword (i.e. you indented something) except for `if` --&gt;

&lt;!-- Global variables inside a local scope are inherted for reading, not writing --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x, y = 1, 2; --&gt;
&lt;!-- function foo() --&gt;
&lt;!--   x = 2        # assignment introduces a new local --&gt;
&lt;!--   return x + y # y refers to the global --&gt;
&lt;!-- end; --&gt;
&lt;!-- foo() --&gt;
&lt;!-- x --&gt;
&lt;!-- ``` --&gt;

&lt;!-- `foo` did not alter the value of `x` defined outside its local scope --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- Important piece: nested functions can modify their parent scope's *local* variables --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x, y = 1, 2; # set globals --&gt;

&lt;!-- function f_outer() --&gt;
&lt;!--   x = 2                # introduces a new local --&gt;
&lt;!--   function f_inner() --&gt;
&lt;!--     x = 10             # modifies the parent's x --&gt;
&lt;!--     return x + y       # y is global --&gt;
&lt;!--   end --&gt;
&lt;!--   return f_inner() + x # 12 + 10 (x is modified in call of bar()) --&gt;
&lt;!-- end; --&gt;
&lt;!-- f_outer() --&gt;
&lt;!-- x, y                   # verify that global x and y are unchanged --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- If `f_inner` was not nested and was in the global scope we'd get `14` not `22`, this is also a way to handle the issue with loops editing variables not created in their local scope --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Scope --&gt;

&lt;!-- We can fix looping issues with global scope by using a wrapper function that doesn't do anything but change the parent scope so it is not global --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function wrapper() --&gt;
&lt;!--   zzz = 0; --&gt;
&lt;!--   for iii = 1:10 --&gt;
&lt;!--     zzz = iii --&gt;
&lt;!--   end --&gt;
&lt;!--   println("zzz = $zzz")  --&gt;
&lt;!-- end --&gt;
&lt;!-- wrapper() --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- These inner functions we've been looking at are called **closures** --&gt;

&lt;!-- When a function `f` is parsed in Julia, it looks to see if any of the variables have been previously defined in the current scope --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- a = 0.2; --&gt;
&lt;!-- f(x) = a * x^2;    # refers to the `a` in the outer scope --&gt;
&lt;!-- f(1)               # univariate function --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function g(a) --&gt;
&lt;!--     f(x) = a * x^2; # refers to the `a` passed in the function --&gt;
&lt;!--     f(1);           # univariate function --&gt;
&lt;!-- end --&gt;
&lt;!-- g(0.2) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- In both of these examples `f` is a closure designed to **capture** a variable from an outer scope --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- Here's a complicated example that actually returns a closure (a function!) itself: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- x = 0; --&gt;
&lt;!-- function toplevel(y) --&gt;
&lt;!--   println("x = ", x, " is a global variable") --&gt;
&lt;!--   println("y = ", y, " is a parameter") --&gt;
&lt;!--   z = 2 --&gt;
&lt;!--   println("z = ", z, " is a local variable") --&gt;

&lt;!--   function closure(v) --&gt;
&lt;!--     println("v = ", v, " is a parameter") --&gt;
&lt;!--     w = 3 --&gt;
&lt;!--     println("w = ", w, " is a local variable") --&gt;
&lt;!--     println("x = ", x, " is a global variable") --&gt;
&lt;!--     println("y = ", y, " is a closed variable (a parameter of the outer function)") --&gt;
&lt;!--     println("z = ", z, " is a closed variable (a local of the outer function)") --&gt;
&lt;!--   end; --&gt;
&lt;!--   return closure --&gt;
&lt;!-- end; --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Closures --&gt;

&lt;!-- Here's a complicated example: --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- c_func = toplevel(10) --&gt;
&lt;!-- c_func(20) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- The returned closure still has access to the outer function's local scope! --&gt;



&lt;!-- --- --&gt;

&lt;!-- # Generic functions --&gt;

&lt;!-- If you go down a computational route with research a goal you should have in mind is to write **generic functions** --&gt;

&lt;!-- -- --&gt;

&lt;!-- These are functions that are flexible (e.g. can deal with someone using an `Int` instead of a `Float`)   --&gt;
&lt;!-- and have high performance (e.g. comparable speed to C) --&gt;

&lt;!-- -- --&gt;

&lt;!-- Functions are made generic by paying attention to types and making sure types are **stable** --&gt;

&lt;!-- -- --&gt;

&lt;!-- **Type stability:** Given an input, operations on that input should maintain the type so Julia **knows** what its type will be throughout --&gt;

&lt;!-- -- --&gt;

&lt;!-- This allows it to compile type-specialized versions of the functions, which will yield higher performance --&gt;

&lt;!-- -- --&gt;

&lt;!-- The question you might have is: Type stability sounds like mandating types, so how do we make it flexible? --&gt;

&lt;!-- -- --&gt;

&lt;!-- We'll see next --&gt;

&lt;!-- --- --&gt;

&lt;!-- # These two functions look the same, but are they? --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- function t1(n) --&gt;
&lt;!--   s = 0 --&gt;
&lt;!--   t = 1 --&gt;
&lt;!--   for i in 1:n --&gt;
&lt;!--      s += s/i --&gt;
&lt;!--      t = div(t, i) --&gt;
&lt;!--   end --&gt;
&lt;!--   return t --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{julia} --&gt;
&lt;!-- function t2(n) --&gt;
&lt;!--   s  = 0.0 --&gt;
&lt;!--   t = 1 --&gt;
&lt;!--   for i in 1:n --&gt;
&lt;!--      s += s/i --&gt;
&lt;!--      t = div(t, i) --&gt;
&lt;!--   end --&gt;
&lt;!--   return t --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # No! t1 is not type stable --&gt;

&lt;!-- -- --&gt;

&lt;!-- `t1` starts with `s` as an `Int64` but then we have `s += s/i` which will mean it must hold a `Float64` --&gt;

&lt;!-- -- --&gt;

&lt;!-- It must be converted to `Float` so it is not type stable --&gt;

&lt;!-- -- --&gt;

&lt;!-- We can see this when calling the macro `@code_warntype` where it reports `t1` must at some point handle a variable that is `Union{Float64,Int64}`, either `Float64` or `Int64` --&gt;

&lt;!-- Julia now can't assume `s`'s type and produce pure integer or floating point code `\(\rightarrow\)` performance degradation --&gt;

&lt;!-- &lt;div align="center"&gt; --&gt;
&lt;!--   &lt;img src="figures/code_warntype.png" height=350&gt; --&gt;
&lt;!-- &lt;/div&gt; --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- A **concrete type** is one that can be instantiated (`Float64` `Bool` `Int32`) --&gt;

&lt;!-- -- --&gt;

&lt;!-- An **abstract type** cannot (`Real`, `Number`, `Any`) --&gt;

&lt;!-- -- --&gt;

&lt;!-- Abstract types are for organizing the types --&gt;

&lt;!-- You can check where types are in the hierarchy --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- @show Float64 &lt;: Real --&gt;
&lt;!-- @show Array &lt;: Real --&gt;
&lt;!-- @show Number &lt;: Any --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Concrete vs abstract types --&gt;

&lt;!-- You can see the type hierarchy with the supertypes and subtypes commands --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- using Base: show_supertypes --&gt;
&lt;!-- show_supertypes(Float64) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- We can actually create new composite types using `struct` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- struct FoobarNoType # This will be immutable by default --&gt;
&lt;!--   a --&gt;
&lt;!--   b --&gt;
&lt;!--   c --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This creates a new type called `FoobarNoType`, and we can generate a variable of this type using its **constructor** which will have the same name --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- newfoo = FoobarNoType(1.3, 2, "plzzz"); --&gt;
&lt;!-- typeof(newfoo) --&gt;
&lt;!-- newfoo.a --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ### You should always declare types for the fields of a new composite type --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Creating new types --&gt;

&lt;!-- You can declare types with the double colon --&gt;


&lt;!-- ```{julia} --&gt;
&lt;!-- struct FoobarType # This will be immutable by default --&gt;
&lt;!--   a::Float64 --&gt;
&lt;!--   b::Int --&gt;
&lt;!--   c::String --&gt;
&lt;!-- end --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- newfoo_typed = FoobarType(1.3, 2, "plzzz"); --&gt;
&lt;!-- typeof(newfoo_typed) --&gt;
&lt;!-- newfoo.a --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This lets the compiler generate efficient code because it knows the types of the fields when you construct a `FoobarType` --&gt;

&lt;!-- Declaring abstract types isn't good enough, you need to declare concrete types --&gt;

&lt;!-- -- --&gt;

&lt;!-- Or do we? --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Parametric types are what help deliver flexibility --&gt;

&lt;!-- We can create types that hold different types of fields by declaring subsets of abstract types --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- struct FooParam{t1 &lt;: Real, t2 &lt;: Real, t3 &lt;: AbstractArray{&lt;:Real}} --&gt;
&lt;!--   a::t1 --&gt;
&lt;!--   b::t2 --&gt;
&lt;!--   c::t3  --&gt;
&lt;!-- end --&gt;
&lt;!-- newfoo_para = FooParam(1.0, 7, [1., 4., 6.]) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- The curly brackets declare all the different type subsets we will use in `FooParam` --&gt;

&lt;!-- -- --&gt;

&lt;!-- This actually delivers high performance code! --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Smart use of existing Julia functions delivers flexibility --&gt;

&lt;!-- We want to make sure types are stable but code is flexible --&gt;

&lt;!-- Ex: if want to preallocate an array to store data, how do we know how to declare it's type? --&gt;

&lt;!-- -- --&gt;

&lt;!-- We don't need to --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- using LinearAlgebra               # necessary for I --&gt;
&lt;!-- function sametypes(x) --&gt;
&lt;!--   y = similar(x)                  # creates an array that is `similar` to x, use this for preallocating --&gt;
&lt;!--   z = I                           # creates a scalable identity matrix --&gt;
&lt;!--   q = ones(eltype(x), length(x))  # one is a type generic array of ones, fill creates the array of length(x) --&gt;
&lt;!--   y .= z * x + q --&gt;
&lt;!--   return y --&gt;
&lt;!-- end --&gt;

&lt;!-- x = [5.5, 7.0, 3.1]; --&gt;
&lt;!-- y = [7, 8, 9]; --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- We did not declare any types but the function is type stable --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Smart use of existing Julia functions delivers flexibility --&gt;

&lt;!-- ```{julia}  --&gt;
&lt;!-- sametypes(x) --&gt;
&lt;!-- sametypes(y) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;

&lt;!-- There's a lot of other functions out there that help with writing flexible, type stable code --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Multiple dispatch --&gt;

&lt;!-- Neat thing about Julia: the same function name can perform different operations depending on the underlying type of the inputs --&gt;

&lt;!-- A function specifies different **methods**, each of which operates on a specific set of types --&gt;

&lt;!-- `/` has 103 different methods depending on the input types, these are 103 specialized sets of codes --&gt;

&lt;!-- ```{julia} --&gt;
&lt;!-- methods(/) --&gt;
&lt;!-- ```   --&gt;


&lt;!-- --- --&gt;

&lt;!-- # Coding practices etc --&gt;

&lt;!-- See [JuliaPraxis](https://github.com/JuliaPraxis) for best practices for naming, spacing, comments, etc --&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
