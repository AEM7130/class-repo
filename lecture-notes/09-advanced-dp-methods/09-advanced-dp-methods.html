<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 9</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ivan Rudik" />
    <script src="09-advanced-dp-methods_files/header-attrs/header-attrs.js"></script>
    <link href="09-advanced-dp-methods_files/remark-css/default.css" rel="stylesheet" />
    <link href="09-advanced-dp-methods_files/remark-css/metropolis.css" rel="stylesheet" />
    <link href="09-advanced-dp-methods_files/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="my-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Lecture 9
]
.subtitle[
## Advanced Methods for Numerical Dynamic Models
]
.author[
### Ivan Rudik
]
.date[
### AEM 7130
]

---

exclude: true

```r
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  xaringanExtra, JuliaCall
)
options(htmltools.dir.version = FALSE)
library(knitr)
opts_chunk$set(
  prompt = T, ## See hook below. I basically want a "$" prompt for every bash command in this lecture.
  fig.align = "center", fig.width=10, fig.height=6, 
  out.width="748px", out.length="520.75px",
  dpi = 300, #fig.path='Figs/',
  cache = F#, echo=F, warning=F, message=F
  )
## Next hook based on this SO answer: https://stackoverflow.com/a/39025054
knit_hooks$set(
  prompt = function(before, options, envir) {
    options(
      prompt = if (options$engine %in% c('sh','bash')) '$ ' else ' ',
      continue = if (options$engine %in% c('sh','bash')) '$ ' else ' '
      )
})
julia_setup(JULIA_HOME = "/Applications/Julia-1.8.app/Contents/Resources/julia/bin")
```


---

# Roadmap

1. Regression
2. Endogenous grid method
3. Envelope condition method
4. Modified policy iteration

---

# Chebyshev regression

Chebyshev regression works just like normal regression

--

For a degree `\(n\)` polynomial approximation, we choose `\(m &gt; n+1\)` grid points

--

We then build our basis function matrix `\(\Psi\)`, but instead of being `\(n \times n\)` it is `\(m \times n\)`

--

Finally we use the standard least-squares equation
`$$c = (\Psi'\Psi)^{-1}\Psi'y$$`

--

Fun fact: `\((\Psi'\Psi)^{-1}\Psi'\)` is a pseudoinverse called the Moore-Penrose matrix inverse

--

We can apply Chebyshev regression to even our regular tensor approaches, this has the advantage of dropping higher order terms which often oscillate due to error, giving us a smoother approximation

---

# Chebyshev regression: practice

Go back to our original VFI example and convert it to a regression approach


```julia
 using LinearAlgebra
 using Optim 
 using Plots
 params = (alpha = 0.75, beta = 0.95, eta = 2,
                 steady_state = (0.75*0.95)^(1/(1 - 0.75)), k_0 = (0.75*0.95)^(1/(1 - 0.75))*.75,
                 capital_upper = (0.75*0.95)^(1/(1 - 0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1 - 0.75))/2,
                 num_basis = 7, num_points = 9, tolerance = 0.0001, fin_diff = 1e-6, mpi_start = 5);
 
 coefficients = zeros(params.num_basis);
 coefficients[1:2] = [100 5];
```

---

# Chebyshev regression: practice


```julia
 cheb_nodes(n) = cos.(pi * (2*(1:n) .- 1)./(2n))
```

```
## cheb_nodes (generic function with 1 method)
```

```julia
 grid = cheb_nodes(params.num_points) # [-1, 1] grid
```

```
## 9-element Vector{Float64}:
##   0.984807753012208
##   0.8660254037844387
##   0.6427876096865394
##   0.3420201433256688
##   6.123233995736766e-17
##  -0.3420201433256687
##  -0.642787609686539
##  -0.8660254037844385
##  -0.984807753012208
```

```julia
 expand_grid(grid, params) = (1 .+ grid)*(params.capital_upper - params.capital_lower)/2 .+ params.capital_lower
```

```
## expand_grid (generic function with 1 method)
```

```julia
 capital_grid = expand_grid(grid, params)
```

```
## 9-element Vector{Float64}:
##  0.3846146682813062
##  0.3693086795455801
##  0.3405428302079919
##  0.3017867062373766
##  0.2577148681640623
##  0.21364303009074814
##  0.17488690612013275
##  0.14612105678254464
##  0.13081506804681853
```

---

# Chebyshev regression: practice


```julia
 # Chebyshev polynomial function
 function cheb_polys(x, n)
     if n == 0
         return 1                    # T_0(x) = 1
     elseif n == 1
         return x                    # T_1(x) = x
     else
         cheb_recursion(x, n) =
             2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
         return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
     end
 end;
 
 basis_matrix = [cheb_polys.(grid, n) for n = 0:params.num_basis - 1];
 basis_matrix = hcat(basis_matrix...);
 basis_inverse = inv(basis_matrix'*basis_matrix)*(basis_matrix'); # pre-compute pseudoinverse for regressions
```

```
## 7×9 Matrix{Float64}:
##  0.111111   0.111111      0.111111   …   0.111111    0.111111      0.111111
##  0.218846   0.19245       0.142842      -0.142842   -0.19245      -0.218846
##  0.208821   0.111111     -0.0385885     -0.0385885   0.111111      0.208821
##  0.19245   -3.13858e-17  -0.19245        0.19245     2.41508e-16  -0.19245
##  0.170232  -0.111111     -0.208821      -0.208821   -0.111111      0.170232
##  0.142842  -0.19245      -0.0760045  …   0.0760045   0.19245      -0.142842
##  0.111111  -0.222222      0.111111       0.111111   -0.222222      0.111111
```

---

# Chebyshev regression: practice


```julia
 shrink_grid(capital) = 2*(capital - params.capital_lower)/(params.capital_upper - params.capital_lower) - 1;
 eval_value_function(coefficients, capital, params) = 
     coefficients' * [cheb_polys.(shrink_grid(capital), n) for n = 0:params.num_basis - 1];
```

---

# Chebyshev regression: practice


```julia
 function loop_grid_regress(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
     max_value = -.0*ones(params.num_points);
     consumption_store = -.0*ones(params.num_points);
 
     for (iteration, capital) in enumerate(capital_grid)
         function bellman(consumption)
             capital_next = capital^params.alpha - consumption
             cont_value = eval_value_function(coefficients, capital_next, params)
             value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
             return -value_out
         end;
 
         results = optimize(bellman, 0.00*capital^params.alpha, 0.99*capital^params.alpha)
         max_value[iteration] = -Optim.minimum(results)
         consumption_store[iteration] = Optim.minimizer(results)
     end
 
     return max_value, consumption_store
 end;
```

---

# Chebyshev regression: practice


```julia
 function solve_vfi_regress(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
 
     max_value = -.0*ones(params.num_points);
     error = 1e10;
     value_prev = .1*ones(params.num_points);
     coefficients_store = Vector{Vector}(undef, 1)
     coefficients_store[1] = coefficients
     iteration = 1
 
     while error &gt; params.tolerance
         max_value, consumption_store = loop_grid_regress(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
         coefficients = basis_inverse*max_value
         error = maximum(abs.((max_value - value_prev)./(value_prev)))
         value_prev = deepcopy(max_value)
         if mod(iteration, 5) == 0
             println("Maximum Error of $(error) on iteration $(iteration).")
             append!(coefficients_store, [coefficients])
         end
         iteration += 1
     end
 
     return coefficients, max_value, coefficients_store
 end;
```
---

# Chebyshev regression: practice


```julia
 @time solution_coeffs, max_value, intermediate_coefficients =
     solve_vfi_regress(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
```

```
## Maximum Error of 0.33656462321563546 on iteration 5.
## Maximum Error of 15.324437748785257 on iteration 10.
## Maximum Error of 0.19176452946373146 on iteration 15.
## Maximum Error of 0.07999511358219082 on iteration 20.
## Maximum Error of 0.0455754939681826 on iteration 25.
## Maximum Error of 0.029268260045592073 on iteration 30.
## Maximum Error of 0.020007154816710206 on iteration 35.
## Maximum Error of 0.014198326541473252 on iteration 40.
## Maximum Error of 0.010323846907305917 on iteration 45.
## Maximum Error of 0.007632084134370531 on iteration 50.
## Maximum Error of 0.005708492913566266 on iteration 55.
## Maximum Error of 0.004305925733500567 on iteration 60.
## Maximum Error of 0.003268177593053183 on iteration 65.
## Maximum Error of 0.0024920065993268136 on iteration 70.
## Maximum Error of 0.0019067690948824706 on iteration 75.
## Maximum Error of 0.0014628021447219033 on iteration 80.
## Maximum Error of 0.0011244465442100749 on iteration 85.
## Maximum Error of 0.0008656712708538149 on iteration 90.
## Maximum Error of 0.0006672266517800869 on iteration 95.
## Maximum Error of 0.0005147333938726661 on iteration 100.
## Maximum Error of 0.0003973654835929178 on iteration 105.
## Maximum Error of 0.00030692204191609364 on iteration 110.
## Maximum Error of 0.0002371610957818922 on iteration 115.
## Maximum Error of 0.00018331403775187195 on iteration 120.
## Maximum Error of 0.00014172736178258514 on iteration 125.
## Maximum Error of 0.00010959565499985235 on iteration 130.
##   0.581542 seconds (8.87 M allocations: 214.767 MiB, 6.98% gc time, 40.79% compilation time: 1% of which was recompilation)
```

```
## ([-194.51557325731787, 14.142103107652055, -2.6644223024373233, 0.5749555213583148, -0.13337383271711795, 0.034569849242611805, -0.008457437727749343], [-182.67782728821018, -183.55636277379813, -185.34986962790762, -188.12961711272612, -191.9763675748722, -196.87361104938967, -202.51418932831817, -207.98861711010005, -211.57369745053882], Vector[[100.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0], [36.80824360742958, 8.655023913144976, -1.483288308822478, 0.31548230941626676, -0.0704179524965467, 0.015491954698058905, -0.0031249287075875818], [-15.489112132969467, 12.459720560253233, -2.3788570165631397, 0.5220670595504612, -0.12339307775844895, 0.0308680215371702, -0.007025248507320953], [-56.149142130428814, 13.65330039841521, -2.587293221282717, 0.5617619282534533, -0.1316736705756989, 0.03392533675691004, -0.00811259703266288], [-87.56105719304848, 14.000160018116718, -2.6421055644479194, 0.5710812787118758, -0.13292760400931444, 0.034416774459782515, -0.0083644578779202], [-111.84446197783181, 14.10101702985609, -2.6579273899477873, 0.5738078239826391, -0.1332412706281449, 0.03452659722295687, -0.008430772885008262], [-130.62706192298657, 14.1302361426601, -2.6625399953996833, 0.5746203316572468, -0.13333474637697418, 0.034557277217562424, -0.0084497147763615], [-145.15842871089106, 14.13867857607071, -2.663878278905609, 0.5748583874456623, -0.13336245582577536, 0.03456620363025852, -0.008455204294232958], [-156.40186295227778, 14.141115170781706, -2.6642652585232938, 0.5749274575028426, -0.13337054025397946, 0.03456879532540852, -0.008456792812691087], [-165.10162644542007, 14.141818128829598, -2.6643769902769274, 0.5749474217843956, -0.13337288189926438, 0.03456954498563605, -0.008457251630833568]  …  [-191.03462199910558, 14.142103093996631, -2.6644223002657883, 0.5749555209700655, -0.13337383267153322, 0.034569849228042446, -0.008457437718853707], [-191.89971736884283, 14.142103103713293, -2.6644223018109816, 0.5749555212463173, -0.133373832703987, 0.03456984923841513, -0.008457437725202318], [-192.56911167429894, 14.142103106516029, -2.664422302256689, 0.5749555213259997, -0.1333738327133583, 0.034569849241395625, -0.008457437727020449], [-193.08707622731092, 14.142103107324461, -2.6644223023852627, 0.574955521348975, -0.1333738327160189, 0.034569849242266214, -0.008457437727546986], [-193.48786732466854, 14.142103107557618, -2.664422302422341, 0.5749555213556261, -0.13337383271680678, 0.03456984924250408, -0.008457437727693], [-193.79799183570518, 14.142103107624852, -2.664422302433026, 0.5749555213575366, -0.13337383271704284, 0.034569849242575085, -0.00845743772774468], [-194.0379602705915, 14.142103107644214, -2.6644223024361082, 0.5749555213580809, -0.13337383271711056, 0.03456984924260254, -0.00845743772774505], [-194.22364327110682, 14.142103107649833, -2.6644223024369738, 0.5749555213582457, -0.13337383271712694, 0.03456984924260908, -0.00845743772776161], [-194.36732123732284, 14.142103107651488, -2.6644223024372917, 0.5749555213582809, -0.13337383271710512, 0.034569849242634655, -0.0084574377277612], [-194.47849650871945, 14.142103107651975, -2.6644223024373743, 0.574955521358291, -0.13337383271714962, 0.034569849242627015, -0.008457437727753293]])
```


---

# Chebyshev regression: practice


```julia
 function simulate_model(params, solution_coeffs, time_horizon = 100)
     capital_store = zeros(time_horizon + 1)
     consumption_store = zeros(time_horizon)
     capital_store[1] = params.k_0
 
     for t = 1:time_horizon
         capital = capital_store[t]
         
         function bellman(consumption)
             capital_next = capital^params.alpha - consumption
             cont_value = eval_value_function(solution_coeffs, capital_next, params)
             value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
             return -value_out
         end;
 
         results = optimize(bellman, 0.0, capital^params.alpha)
         consumption_store[t] = Optim.minimizer(results)
         capital_store[t+1] = capital^params.alpha - consumption_store[t]
     end
 
     return consumption_store, capital_store
 end;
```

---

# Chebyshev regression: practice

&lt;img src="09-advanced-dp-methods_files/figure-html/unnamed-chunk-9-J1.png" width="748px" style="display: block; margin: auto;" /&gt;

---

# Endogenous grid method (Carroll, 2006)

Suppose now we are working with a model with an inelastic labor supply with logarithmic utility `\(\eta=1\)`, and capital that fully depreciates

--

Leisure does not enter the utility function nor does labor enter the production function, i.e. `\(B = 0, l = 1\)`

--

This yields closed form solutions to the model
`\begin{align}
 	k_{t+1} &amp;= \beta \alpha \theta_t k_t^\alpha \notag\\
 	c_t &amp;= (1-\beta\alpha)\theta_t k_t^\alpha
\end{align}`

--

The endogenous grid method was introduced by Carroll (2006) for value function iteration

---

# Endogenous grid method (Carroll, 2006)

The idea behind EGM is .hi-blue[super simple]

--

instead of constructing a grid on the current states, construct the grid on .hi-red[future states] (making current states endogenous)

--

This works to our advantage because typically it is easier to solve for `\(k\)` given `\(k'\)` than the reverse

--

Let's see how this works

---

# Endogenous grid method

1. Choose a grid `\(\left\{k_m',\theta_m\right\}_{m=1,...,M}\)` on which the value function is approximated
2. Choose nodes `\(\epsilon_j\)` and weights `\(\omega_j\)`, `\(j=1,...,J\)` for approximating integrals.
3. Compute next period productivity, `\(\theta'_{m,j} = \theta_m^\rho exp(\epsilon_j)\)`.
4. Solve for `\(b\)` and `\(\left\{ c_m,k_m \right\}\)` such that
  + (inner loop) The quantities `\(\left\{c_m,k_m	\right\}\)` solve the following given `\(V(k'_m,\theta'_m)\)`:
      - `\(u'(c_m) = \beta E\left[ V_k(k'_m,\theta'_{m,j}) \right]\)`,
      - `\(c_m + k'_m = \theta_m f(k_m) + (1-\delta)k_m\)`
  + (outer loop) The value function `\(\hat{V}(k,\theta;b)\)` solves the following given `\(\{ c_m,k'_m \}\)`:
      - `\(\hat{V}(k_m,\theta_m;b) = u(c_m) + \beta \sum_{j=1}^J \omega_j \left[\hat{V}(k'_m,\theta'_{m,j};b)\right]\)`

---

# Endogenous grid method

.hi-blue[Focus the inner loop of VFI:]  
+ (inner loop) The quantities `\(\left\{c_m,k_m	\right\}\)` solve the following given `\(V(k'_m,\theta'_m)\)`:
    - `\(u'(c_m) = \beta E\left[ V_k(k'_m,\theta'_{m,j}) \right]\)`,
    - `\(c_m + k'_m = \theta_m f(k_m) + (1-\delta)k_m\)`

Notice that the values of `\(k'\)` are fixed since they are grid points

--

This means that we can pre-compute the expectations of the value function and value function derivatives and let `\(W(k',\theta) = E[V(k',\theta';b)]\)`

--

We can then use the consumption FOC to solve for consumption, `\(c = [\beta W_k(k',\theta)]^{-1/\gamma}\)` and then rewrite the resource constraint as,
`$$(1-\delta)k + \theta k^\alpha = [\beta W_k(k',\theta)]^{-1/\gamma} + k'$$`

---

# Endogenous grid method

This is easier to solve than the necessary conditions we would get out of standard value function iteration
`$$(k'-(1-\delta)k - \theta k^\alpha)^{-\gamma} = \beta W_k(k',\theta')$$`

--

Why?

--

We do not need to do any interpolation ( `\(k'\)` is on our grid)

--

We do not need to approximate a conditional expectation (already did it before hand and can do it with very high accuracy since it is a one time cost)

--

Can we make the algorithm better?

---

# Endogenous grid method: turbo speed

Let's make a change of variables
`$$Y \equiv (1-\delta)k + \theta k^\alpha = c + k'$$`

--

so we can rewrite the Bellman as
`\begin{gather}
	V(Y,\theta) = \max_{k'} \left\{ \frac{c^{1-\gamma}-1}{1-\gamma} + \beta E\left[ V(Y',\theta') \right] \right\} \notag\\
	\text{s.t.} \,\,\, c = Y - k' \notag\\
	Y' = (1-\delta)k' + \theta'(k')^\alpha \notag
\end{gather}`

---

# Endogenous grid method: turbo speed

This yields the FOC
`$$u'(c) = \beta E\left[ V_Y(Y',\theta') (1-\delta + \alpha\theta'(k')^{\alpha-1}) \right]$$`

--

`\(Y'\)` is a simple function of `\(k'\)` (our grid points) so we can compute it, and the entire conditional expectation on the RHS, directly from the endogenous grid points

---

# Endogenous grid method: turbo speed

`$$u'(c) = \beta E\left[ V_Y(Y',\theta') (1-\delta + \alpha\theta'(k')^{\alpha-1}) \right]$$`

This allows us to compute `\(c\)` from the FOC

--

Then from `\(c\)` we can compute `\(Y = c + k'\)` and then `\(V(Y,\theta)\)` from the Bellman

--

At no point did we need to use a numerical solver

--

Once we have converged on some `\(\hat{V}^*\)` we then solve for `\(k\)` via `\(Y = (1-\delta)k + \theta k^\alpha\)` which does require a solver, but only once and after we have recovered our value function approximant

---

# Endogenous grid method: practice

Let's solve our previous basic growth model using EGM


```julia
 coefficients = zeros(params.num_basis);
 coefficients[1:2] = [100 5];
```

---

# Endogenous grid method: practice


```julia
 function loop_grid_egm(params, capital_grid, coefficients)
 
     max_value = similar(capital_grid)
     capital_store = similar(capital_grid)
 
     for (iteration, capital_next) in enumerate(capital_grid)
 
         function bellman(consumption)
             cont_value = eval_value_function(coefficients, capital_next, params)
             value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
             return value_out
         end;
         value_deriv = (eval_value_function(coefficients, capital_next + params.fin_diff, params) -
             eval_value_function(coefficients, capital_next - params.fin_diff, params))/(2params.fin_diff)
         consumption = (params.beta*value_deriv)^(-1/params.eta)
         max_value[iteration] = bellman(consumption)
         capital_store[iteration] = (capital_next + consumption)^(1/params.alpha)
     end
 
     grid = shrink_grid.(capital_store)
     basis_matrix = [cheb_polys.(grid, n) for n = 0:params.num_basis - 1];
     basis_matrix = hcat(basis_matrix...)
     return basis_matrix, capital_store, max_value
 
 end
```

```
## loop_grid_egm (generic function with 1 method)
```

---

# Endogenous grid method: practice


```julia
 function solve_egm(params, capital_grid, coefficients)
     iteration = 1
     error = 1e10;
     max_value = -.0*ones(params.num_points);
     value_prev = .1*ones(params.num_points);
     coefficients_store = Vector{Vector}(undef, 1)
     coefficients_store[1] = coefficients
     while error &gt; params.tolerance
         coefficients_prev = deepcopy(coefficients)
         current_poly, current_capital, max_value =
             loop_grid_egm(params, capital_grid, coefficients)
         coefficients = current_poly\max_value
         error = maximum(abs.((max_value - value_prev)./(value_prev)))
         value_prev = deepcopy(max_value)
         if mod(iteration, 5) == 0
             println("Maximum Error of $(error) on iteration $(iteration).")
             append!(coefficients_store, [coefficients])
         end
         iteration += 1
     end
 
     return coefficients, max_value, coefficients_store
 end
```

```
## solve_egm (generic function with 1 method)
```
No need to pass basis function matrices or `\([-1,1]\)` grid since we will be constructing an endogenous grid on time `\(t\)` capital

---

# Endogenous grid method: practice


```julia
 @time solution_coeffs, max_value, intermediate_coefficients = solve_egm(params, capital_grid, coefficients)
```

```
## Maximum Error of 0.33984199435214524 on iteration 5.
## Maximum Error of 10.282284261431627 on iteration 10.
## Maximum Error of 0.20342072897811764 on iteration 15.
## Maximum Error of 0.08237320857778223 on iteration 20.
## Maximum Error of 0.04652351103135058 on iteration 25.
## Maximum Error of 0.02976136784252069 on iteration 30.
## Maximum Error of 0.020301746220850122 on iteration 35.
## Maximum Error of 0.014389171942098105 on iteration 40.
## Maximum Error of 0.01045397324506247 on iteration 45.
## Maximum Error of 0.007723897635043133 on iteration 50.
## Maximum Error of 0.005774836832471519 on iteration 55.
## Maximum Error of 0.004354692326419023 on iteration 60.
## Maximum Error of 0.0033044754037397984 on iteration 65.
## Maximum Error of 0.0025192760997872405 on iteration 70.
## Maximum Error of 0.0019273992794483531 on iteration 75.
## Maximum Error of 0.001478492015114454 on iteration 80.
## Maximum Error of 0.0011364270991021624 on iteration 85.
## Maximum Error of 0.0008748474931101615 on iteration 90.
## Maximum Error of 0.0006742714486808205 on iteration 95.
## Maximum Error of 0.0005201515977709989 on iteration 100.
## Maximum Error of 0.0004015384211377455 on iteration 105.
## Maximum Error of 0.0003101393316254881 on iteration 110.
## Maximum Error of 0.0002396436506880333 on iteration 115.
## Maximum Error of 0.00018523085528019155 on iteration 120.
## Maximum Error of 0.0001432080898119225 on iteration 125.
## Maximum Error of 0.00011073993961169108 on iteration 130.
##   0.295677 seconds (2.93 M allocations: 111.441 MiB, 2.98% gc time, 73.80% compilation time: 5% of which was recompilation)
```

```
## ([-194.52555937604515, 14.166836739172375, -2.6599927533337593, 0.5620085823803014, -0.1362390390002211, 0.04258691877293904, -0.008536910651997956], [-180.80823807037967, -181.83458341164112, -183.95232673515272, -187.3279556298509, -192.0503518916305, -198.03098517457863, -205.00341570428833, -211.9377570960503, -216.53192927839737], Vector[[100.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0], [36.86590610646693, 8.558371652044116, -1.4244049058853627, 0.2872774922409924, -0.05894579838304355, 0.010642877317048874, -0.0010843988491282916], [-15.45226318447712, 12.421487352604755, -2.3655568384670134, 0.5201475082036802, -0.12858494440280216, 0.03366833372382972, -0.005241936153671935], [-56.125099567065455, 13.63930604723264, -2.574369607539361, 0.5540556560753682, -0.13782235650704322, 0.04108471079605164, -0.0075908313300008115], [-87.55047268648673, 14.00562632458952, -2.6316545095677233, 0.5589799444689235, -0.13691130847867652, 0.04226173793778032, -0.00826423802527813], [-111.84260740912588, 14.118159833457714, -2.6509270655839816, 0.5609126272967021, -0.13641913219851454, 0.042489868487348856, -0.00845461036933398], [-130.6295939221367, 14.15227475163716, -2.657205713608879, 0.5616557231064078, -0.13628726214354767, 0.0425564465944883, -0.008512038105897986], [-145.16324319741145, 14.162496989849892, -2.659153008998984, 0.5619007424763389, -0.13625265180979115, 0.042577581763968156, -0.0085294571139494], [-156.40804470601495, 14.16554501544419, -2.659741797178174, 0.5619762220420111, -0.13624300537153802, 0.04258410812469484, -0.008534687528044356], [-165.10873589440135, 14.166452402129352, -2.659917980624227, 0.5619989291450102, -0.13624021020276833, 0.042586079103637674, -0.008536248734609736]  …  [-191.044272381411, 14.166836715579404, -2.6599927487529915, 0.5620085817862084, -0.1362390390783928, 0.04258691872216869, -0.008536910608610365], [-191.90945119063394, 14.166836732150188, -2.659992751973811, 0.5620085822011863, -0.13623903902263218, 0.04258691875880898, -0.008536910639550711], [-192.57891005898114, 14.166836737078597, -2.6599927529361156, 0.5620085823266284, -0.13623903900854897, 0.04258691876886934, -0.008536910647614356], [-193.09692456921744, 14.166836738544445, -2.6599927532177343, 0.5620085823644517, -0.13623903900760084, 0.042586918771498394, -0.008536910649957681], [-193.49775432243254, 14.1668367389812, -2.659992753298081, 0.5620085823718339, -0.13623903900944107, 0.042586918773730845, -0.008536910649342531], [-193.80790874461215, 14.16683673910823, -2.659992753327176, 0.562008582376642, -0.1362390390041224, 0.04258691877429751, -0.008536910650662439], [-194.04790032415798, 14.166836739149923, -2.659992753337864, 0.5620085823822559, -0.13623903899680903, 0.042586918771530875, -0.008536910653705704], [-194.23360123355994, 14.166836739161727, -2.6599927533402217, 0.5620085823788236, -0.13623903900183165, 0.04258691877270481, -0.008536910652291833], [-194.3772930573344, 14.16683673916429, -2.6599927533442265, 0.5620085823771048, -0.13623903900304335, 0.0425869187742848, -0.00853691065167052], [-194.4884790514389, 14.166836739173217, -2.659992753336622, 0.5620085823758, -0.13623903900768716, 0.04258691877357059, -0.008536910650599987]])
```


---

# Endogenous grid method: practice



---

# Endogenous grid method: practice

&lt;img src="09-advanced-dp-methods_files/figure-html/unnamed-chunk-15-J1.png" width="748px" style="display: block; margin: auto;" /&gt;

---

# Envelope condition method

We can simplify rootfinding in an alternative way than an endogenous grid for infinite horizon problems

--

The idea here is that we want to use the envelope conditions instead of FOCs to construct policy functions

--

These will end up being easier to solve and sometimes we can solve them in closed form

---

# Envelope condition method

For our old basic growth model problem (fully depreciating capital, no tech) the envelope condition (combined with the consumption FOC) is given by
`$$V_k(k) = u'(c)f'(k)$$`

--

Notice that the envelope condition is an intratemporal condition,  
it only depends on time `\(t\)` variables

--

We can use it to solve for `\(c\)` as a function of current variables
`$$c = \left( \frac{V_k(k)}{\alpha k^{\alpha-1}} \right)^{-1/\eta}$$`

--

We can then recover `\(k'\)` from the budget constraint given our current state

--

We never need to use a solver at any point in time!

---

# Envelope condition method

The algorithm is
1. Choose a grid `\(\left\{k_m\right\}_{m=1,...,M}\)` on which the value function is approximated
2. Solve for `\(b\)` and `\(\left\{ c_m,k'_m \right\}\)` such that
  - (inner loop) The quantities `\(\left\{c_m,k'_m	\right\}\)` solve the following given `\(V(k_m)\)`:
    + `\(V_k(k_m) = u'(c_m)f'(k_m)\)`,
    + `\(c_m + k'_m = f(k_m)\)`
  - (outer loop) The value function `\(\hat{V}(k;b)\)` solves the following given `\(\{ c_m,k_m \}\)`:
    + `\(\hat{V}(k_m;b) = u(c_m) + \beta \sum_{j=1}^J \omega_j \left[\hat{V}(k'_m;b)\right]\)`

---

# Envelope condition method

In more complex settings (e.g. elastic labor supply) we will not necessarily be able to solve for policies without a solver

--

However we will generally be able to solve a system of conditions via function iteration to recover the optimal controls as a function of current states and future states that are perfectly known at the current time

--

Thus at no point in time during the value function approximation algorithm do we need to interpolate off the grid or approximate expectations: this yields large speed and accuracy gains

---

# Envelope condition method: practice


```julia
 function loop_grid_ecm(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
 
     max_value = similar(capital_grid);
 
     for (iteration, capital) in enumerate(capital_grid)
 
         function bellman(consumption)
             capital_next = capital^params.alpha - consumption
             cont_value = eval_value_function(coefficients, capital_next, params)
             value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
             return value_out
         end;
 
         value_deriv = (eval_value_function(coefficients, capital + params.fin_diff, params) -
             eval_value_function(coefficients, capital - params.fin_diff, params))/(2params.fin_diff)
         consumption = (value_deriv/(params.alpha*capital^(params.alpha-1)))^(-1/params.eta)
         consumption = min(consumption, capital^params.alpha)
         max_value[iteration] = bellman(consumption)
 
     end
 
     return max_value
 end
```

```
## loop_grid_ecm (generic function with 1 method)
```


---

# Envelope condition method: practice


```julia
 function solve_ecm(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
     iteration = 1
     error = 1e10;
     max_value = similar(capital_grid);
     value_prev = .1*ones(params.num_points);
     coefficients_store = Vector{Vector}(undef, 1)
     coefficients_store[1] = coefficients
     while error &gt; params.tolerance
         coefficients_prev = deepcopy(coefficients)
         max_value = loop_grid_ecm(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
         coefficients = basis_inverse*max_value
         error = maximum(abs.((max_value - value_prev)./(value_prev)))
         value_prev = deepcopy(max_value)
         if mod(iteration, 5) == 0
             println("Maximum Error of $(error) on iteration $(iteration).")
             append!(coefficients_store, [coefficients])
         end
         iteration += 1
     end
     return coefficients, max_value, coefficients_store
 end
```

```
## solve_ecm (generic function with 1 method)
```

---

# Envelope condition method: practice


```julia
 @time solution_coeffs, max_value, intermediate_coefficients =
     solve_ecm(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
```

```
## Maximum Error of 0.3527064027921682 on iteration 5.
## Maximum Error of 8.805965928110838 on iteration 10.
## Maximum Error of 0.1896588876725065 on iteration 15.
## Maximum Error of 0.07943447581969357 on iteration 20.
## Maximum Error of 0.04532030555708693 on iteration 25.
## Maximum Error of 0.029127245675426107 on iteration 30.
## Maximum Error of 0.019920679715424265 on iteration 35.
## Maximum Error of 0.014141682933457352 on iteration 40.
## Maximum Error of 0.010285041765030388 on iteration 45.
## Maximum Error of 0.007604645927792631 on iteration 50.
## Maximum Error of 0.005688645480363027 on iteration 55.
## Maximum Error of 0.004291328352579298 on iteration 60.
## Maximum Error of 0.0032573086762268783 on iteration 65.
## Maximum Error of 0.0024838391761297296 on iteration 70.
## Maximum Error of 0.0019005891584989655 on iteration 75.
## Maximum Error of 0.0014581015348507924 on iteration 80.
## Maximum Error of 0.0011208568927137876 on iteration 85.
## Maximum Error of 0.0008629216690145762 on iteration 90.
## Maximum Error of 0.0006651156043542608 on iteration 95.
## Maximum Error of 0.0005131097077489833 on iteration 100.
## Maximum Error of 0.000396114928664237 on iteration 105.
## Maximum Error of 0.00030595785081823356 on iteration 110.
## Maximum Error of 0.0002364170875813676 on iteration 115.
## Maximum Error of 0.00018273957003392212 on iteration 120.
## Maximum Error of 0.0001412835848518871 on iteration 125.
## Maximum Error of 0.00010925270804567991 on iteration 130.
##   0.132908 seconds (1.82 M allocations: 45.708 MiB, 46.14% compilation time)
```

```
## ([-194.51663856763165, 14.142059626813142, -2.6644635315374168, 0.5749537630104119, -0.13338482787537187, 0.03455261978857737, -0.008477622131293267], [-182.67900799006236, -183.5574385688729, -185.35095723871515, -188.13068494984853, -191.97738752647896, -196.8746251602211, -202.51522529150313, -207.98965674114925, -211.5747636418337], Vector[[100.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0], [36.20763531135077, 9.377904708462724, -1.7305255969413151, 0.38019575458490523, -0.08826706541100833, 0.02004965987792946, -0.004993109150506323], [-16.074849210667615, 12.738304053681047, -2.4370364696648625, 0.5336634991144337, -0.12658653297129974, 0.03183839495101113, -0.007955781173414682], [-56.59396757454929, 13.734806168324365, -2.601280701707779, 0.5639243480763936, -0.13190557442548806, 0.0340054581273935, -0.008348190714936718], [-87.89998949688368, 14.024019597646578, -2.646179362667905, 0.5717217855303979, -0.1329713604224939, 0.034409825415862176, -0.008441569068001902], [-112.10482475655353, 14.107923488107, -2.659158174030975, 0.5740061556397605, -0.13326337881111602, 0.03451184869341107, -0.008467173939473428], [-130.82793105204414, 14.132200484409287, -2.662928037029743, 0.5746782905866097, -0.1333493639469811, 0.034540821362312055, -0.008474586620894047], [-145.3136800883302, 14.139213604456307, -2.6640198549020906, 0.5748740412158981, -0.1333745423334995, 0.03454920749456566, -0.008476743123070564], [-156.52194095809512, 14.1412382225251, -2.6643354279027562, 0.5749307325502817, -0.13338185399293698, 0.03455163407919409, -0.008477368108052876], [-165.1945243585121, 14.14182257257333, -2.6644265552234256, 0.5749471142144446, -0.13338396904984245, 0.034552335215284, -0.008477548783645775]  …  [-191.04655408647238, 14.1420596154123, -2.6644635297575623, 0.5749537626928148, -0.1333848278317611, 0.03455261977687204, -0.008477622126132322], [-191.9089488153579, 14.142059623521973, -2.6644635310241096, 0.574953762917273, -0.13338482786328063, 0.034552619785651204, -0.008477622128913218], [-192.5762534165474, 14.1420596258628, -2.664463531390448, 0.5749537629802471, -0.13338482787353742, 0.03455261978705128, -0.008477622131162807], [-193.09260099627244, 14.14205962654355, -2.6644635314906195, 0.5749537630042436, -0.133384827873161, 0.03455261978933026, -0.008477622130122597], [-193.4921409105398, 14.142059626734257, -2.664463531524445, 0.5749537630084437, -0.13338482787480127, 0.03455261979055476, -0.008477622128856211], [-193.8012972799529, 14.14205962679041, -2.664463531532302, 0.5749537630092969, -0.1333848278749688, 0.03455261978796446, -0.008477622130838199], [-194.04051658530855, 14.142059626804784, -2.6644635315366707, 0.5749537630094492, -0.13338482787615535, 0.034552619788404404, -0.00847762213088949], [-194.22561992367258, 14.142059626809495, -2.664463531537617, 0.5749537630090134, -0.13338482787639314, 0.03455261978920371, -0.008477622130870919], [-194.3688493583646, 14.14205962681417, -2.6644635315368532, 0.5749537630093615, -0.13338482787672293, 0.034552619788560536, -0.008477622130705504], [-194.4796775646187, 14.142059626814454, -2.664463531535621, 0.5749537630096757, -0.13338482787491335, 0.03455261978759963, -0.008477622131195768]])
```

---

# Envelope condition method: practice


```julia
 function simulate_model(params, solution_coeffs, time_horizon = 100)
     capital_store = zeros(time_horizon + 1)
     consumption_store = zeros(time_horizon)
     capital_store[1] = params.k_0
 
     for t = 1:time_horizon
         capital = capital_store[t]
 
         function bellman(consumption)
             capital_next = capital^params.alpha - consumption
             cont_value = eval_value_function(solution_coeffs, capital_next, params)
             value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
             return -value_out
         end;
 
         results = optimize(bellman, 0.0, capital^params.alpha)
         consumption_store[t] = Optim.minimizer(results)
         capital_store[t+1] = capital^params.alpha - consumption_store[t]
     end
 
     return consumption_store, capital_store
 end;
```
---

# Envelope condition method: practice


```julia
 time_horizon = 100;
 consumption, capital = simulate_model(params, solution_coeffs, time_horizon);
 plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, label = "Consumption", legend = :right, size = (500, 300));
 plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
 plot!(1:time_horizon, params.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Analytic Steady State")
```

&lt;img src="09-advanced-dp-methods_files/figure-html/unnamed-chunk-20-J1.png" width="748px" style="display: block; margin: auto;" /&gt;

---

# Modified policy iteration

When doing VFI what is the most expensive part of the algorithm?

--

The maximization step!

--

If we can reduce how often we need to maximize the Bellman we can significantly improve speed

--

It turns out that between VFI iterations, the optimal policy does not change all that much

--

This means that we may be able to skip the maximization step and re-use our old policy function to get new values for polynomial fitting

--

This is called **modified policy iteration**

---

# Modified policy iteration

It only change step 5 of VFI:
5. While convergence criterion `\(&gt;\)` tolerance
  + Start iteration `\(p\)`
  + Solve the right hand side of the Bellman equation
  + Recover the maximized values, conditional on `\(\Gamma(k_{t+1};b^{(p)})\)`
  + Fit the polynomial to the values and recover a new vector of coefficients `\(\hat{b}^{(p+1)}\)`.
  + Compute `\(b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}\)` where `\(\gamma \in (0,1).\)`
  + While MPI stop criterion `\(&gt;\)` tolerance
      - Use policies from last VFI iteration to re-fit the polynomial (no maximizing!)
      - Compute `\(b^{(p+1)}\)` for iteration `\(p+1\)` by `\(b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}\)` where `\(\gamma \in (0,1).\)`

---

# Modified policy iteration

Stop criteron can be a few things:
1. Fixed number of iterations
2. Stop when change in value function is sufficient small, QuantEcon suggests stopping MPI when
`$$\max(V_p(x;c) - V_{p-1}(x;c)) -  \min(V_p(x;c) - V_{p-1}(x;c)) &lt; \epsilon(1-\beta)\beta$$`
where the max and min are over the values on the grid

--

Also note: you should probably start MPI after a few VFI iterations unless you have a good initial guess

--

If your early policy functions are bad then starting MPI too early will blow up your problem

---

# Modified policy iteration


```julia
 function solve_vfi_regress_mpi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
     max_value = -.0*ones(params.num_points);
     error = 1e10;
     value_prev = .1*ones(params.num_points);
     value_prev_outer = .1*ones(params.num_points);
     coefficients_store = Vector{Vector}(undef, 1)
     coefficients_store[1] = coefficients
     iteration = 1
     while error &gt; params.tolerance
         max_value, consumption_store =
             loop_grid_regress(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
         coefficients = basis_inverse*max_value
         if iteration &gt; params.mpi_start # modified policy iteration loop
             mpi_iteration = 1
             while maximum(abs.(max_value - value_prev)) - 
                     minimum(abs.(max_value - value_prev)) &gt; 
                     (1 - params.beta)/params.beta*params.tolerance
                 value_prev = deepcopy(max_value)
```

---

# Modified policy iteration


```julia
               function bellman(consumption, capital)
                     capital_next = capital^params.alpha - consumption
                     cont_value = eval_value_function(coefficients, capital_next, params)
                     value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
                     return value_out
                 end
                 max_value = bellman.(consumption_store, capital_grid) # greedy policy
                 coefficients = basis_inverse*max_value
                 if mod(mpi_iteration, 5) == 0
                     println("MPI iteration $mpi_iteration on VFI iteration $iteration.")
                 end
                 mpi_iteration += 1
             end
         end
         error = maximum(abs.((max_value .- value_prev_outer)./(value_prev_outer)))
         value_prev_outer = deepcopy(max_value)
 
         if mod(iteration, 5) == 0
             println("Maximum Error of $(error) on iteration $(iteration).")
             append!(coefficients_store, [coefficients])
         end
         iteration += 1
     end
     return coefficients, max_value, coefficients_store
 end;
```


---

# Modified policy iteration



---

# Modified policy iteration


```julia
 @time solution_coeffs, max_value, intermediate_coefficients =
     solve_vfi_regress_mpi(params, basis_inverse, basis_matrix, grid, capital_grid, coefficients)
```

```
## Maximum Error of 0.33656462321563546 on iteration 5.
## MPI iteration 5 on VFI iteration 6.
## MPI iteration 10 on VFI iteration 6.
## MPI iteration 15 on VFI iteration 6.
## MPI iteration 20 on VFI iteration 6.
## MPI iteration 25 on VFI iteration 6.
## MPI iteration 30 on VFI iteration 6.
## MPI iteration 35 on VFI iteration 6.
## MPI iteration 40 on VFI iteration 6.
## MPI iteration 45 on VFI iteration 6.
## MPI iteration 50 on VFI iteration 6.
## MPI iteration 55 on VFI iteration 6.
## MPI iteration 60 on VFI iteration 6.
## MPI iteration 65 on VFI iteration 6.
## MPI iteration 70 on VFI iteration 6.
## MPI iteration 5 on VFI iteration 7.
## MPI iteration 10 on VFI iteration 7.
## MPI iteration 15 on VFI iteration 7.
## MPI iteration 20 on VFI iteration 7.
## MPI iteration 25 on VFI iteration 7.
## MPI iteration 30 on VFI iteration 7.
## MPI iteration 35 on VFI iteration 7.
## MPI iteration 40 on VFI iteration 7.
## MPI iteration 45 on VFI iteration 7.
## MPI iteration 5 on VFI iteration 8.
## MPI iteration 10 on VFI iteration 8.
## MPI iteration 15 on VFI iteration 8.
## MPI iteration 20 on VFI iteration 8.
## MPI iteration 25 on VFI iteration 8.
## MPI iteration 5 on VFI iteration 9.
## Maximum Error of 7.736999952594901e-5 on iteration 10.
##   0.503292 seconds (2.28 M allocations: 91.774 MiB, 17.37% gc time, 72.80% compilation time)
```

```
## ([-194.98995838541236, 14.14210619572545, -2.664423037631185, 0.5749556856556037, -0.13337386733926979, 0.03456986150617147, -0.00845744223955711], [-183.15220994435174, -184.03074558458732, -185.8242527588519, -188.60400076032522, -192.45075199802352, -197.3479965478694, -202.9885761378912, -208.4630052469076, -212.0480864899035], Vector[[100.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0], [36.80824360742958, 8.655023913144976, -1.483288308822478, 0.31548230941626676, -0.0704179524965467, 0.015491954698058905, -0.0031249287075875818], [-194.98995838541236, 14.14210619572545, -2.664423037631185, 0.5749556856556037, -0.13337386733926979, 0.03456986150617147, -0.00845744223955711]])
```

---

# Modified policy iteration

&lt;img src="09-advanced-dp-methods_files/figure-html/unnamed-chunk-25-J1.png" width="748px" style="display: block; margin: auto;" /&gt;

---

# Modified policy iteration

What was your speed up?

I got **6 times**: 0.6s `\(\rightarrow\)` 0.1s
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
