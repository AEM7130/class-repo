---
title: "Lecture 7"
subtitle: "Solution methods for discrete time dynamic models"
author: Ivan Rudik
date: AEM 7130
output:
  xaringan::moon_reader:
    css: ['default', 'metropolis', 'metropolis-fonts', 'my-css.css']
    # self_contained: true
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9'


---
exclude: true
```{r setup}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  xaringanExtra, JuliaCall
)
options(htmltools.dir.version = FALSE)
library(knitr)
opts_chunk$set(
  prompt = T, ## See hook below. I basically want a "$" prompt for every bash command in this lecture.
  fig.align = "center", fig.width=10, fig.height=6, 
  out.width="748px", out.length="520.75px",
  dpi = 300, #fig.path='Figs/',
  cache = F#, echo=F, warning=F, message=F
  )
## Next hook based on this SO answer: https://stackoverflow.com/a/39025054
knit_hooks$set(
  prompt = function(before, options, envir) {
    options(
      prompt = if (options$engine %in% c('sh','bash')) '$ ' else ' ',
      continue = if (options$engine %in% c('sh','bash')) '$ ' else ' '
      )
})
julia_setup(JULIA_HOME = "/Applications/Julia-1.8.app/Contents/Resources/julia/bin")
```

---

# Roadmap

1. Intuition for solving dynamic models
2. Value function iteration
3. Fixed point iteration
4. Time iteration
5. VFI + discretization

---

# Things to do

1. Install: `LinearAlgebra, Optim, Plots, Roots`
--

2. Keep in mind that for VFI and TI we will be using optimization/rootfinding packages
  - This matters because these packages typically only let the functions they work on have one input: the guesses for the maximizing input or root
  - We get around this by expressing the function as a *closure*
  - i.e. declare the function inside of a wrapper function that does the maximization/rootfinding so it can access the parameters in the wrapper function

---

# Things to do

3. Keep in mind we will be working with about the simplest example possible,  
more complex problems will be more difficult to solve in many ways

---

class: inverse, center, middle
name: why

# How do we solve dynamic models?

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>


---

# Solutions to economic models

How do we solve economic models?

--

First, what do we want?

--

We want to be able to compute things like optimal policy trajectories, welfare, etc

---

# Solutions to economic models

There are generally two objects that can deliver what we want:

1. Value functions
2. Policy functions

--

The idea behind the most commonly used solution concepts is to recover good approximations to one of these two functions

---

# Solutions to economic models

We recover these functions by exploiting two things:

1. Dynamic equilibrium conditions incorporating these functions
  - Bellman
  - Euler
2. Fixed points

---

# Our general example

Consider the following problem we will be using for all the solution methods:
\begin{gather}
  \max_{\left\{c_t \right\}_{t=0}^\infty} \sum_{t=1}^\infty \beta^t u(c_t) \notag \\
  \text{subject to:} \,\,\,\,\, k_{t+1} = f(k_t) - c_t \notag 
\end{gather}
where both consumption and time $t+1$ capital are positive,  
$k(0) = k_0$, $\alpha > 0$, and $\beta \in (0,1)$

---

# Our general example

Represent the growth model as a Bellman equation
\begin{gather}
V(k_t) = \max_{c_t}  u(c_t) + \beta V(k_{t+1}) \notag \\
\text{subject to:} \,\,\,\,\, k_{t+1}' = f(k_t) - c_t \notag 
\end{gather}

--

We can then express the value function in terms of itself, the current state, and the current consumption choice:
$$V(k_t) = \max_{c_t}  u(c_t) + \beta V(f(k_t) - c_t)$$


---

# Our general example

$$V(k_t) = \max_{c_t}  u(c_t) + \beta V(f(k_t) - c_t)$$

How do we solve this?

Main idea:

1. Guess $V(k_t)$
2. Given guess, do the maximization on the right hand side at some set of states $\mathbf{k^i_t}$
3. Maximized right hand side gives us new values of $V(k_t)$
4. Repeat

---

# Our general example

Another equilibrium condition is the .hi[Euler equation]

--

For our problem it is
$$u'(c_t) = \beta u'(c_{t+1}) f'(k_{t+1})$$


Plug in the policy function $c_t = C(k_t)$:

$$u'(C(k_t)) = \beta u'(C(k_{t+1})) f'(k_{t+1})$$


---

# Our general example

Recognize $k_{t+1}$ is a function of the current policy and state $(C(k_t),k_t)$:

$$k_{t+1} = f(k_t) - C(k_t)$$

Use this to express the Euler equation in terms of $k_t$ and $C$

$$C(k_t) = u'^{(-1)}\left[\beta u'\left[C(k_{t+1}(C(k_t),k_t))\right] f'\left[k_{t+1}(C(k_t),k_t)\right]\right]$$

---

# Our general example

$$C(k_t) = u'^{(-1)}\left[\beta u'\left[C(k_{t+1}(C(k_t),k_t))\right] f'\left[k_{t+1}(C(k_t),k_t)\right]\right]$$

How do we solve this?

Main idea:

1. Guess $C(k_t)$
2. Given guess, evaluate the right hand side at some set of states $\mathbf{k^i_t}$
3. Evaluated right hand side gives us new values of $C(k_t)$
4. Repeat

---

class: inverse, center, middle
name: vfi

# Value function iteration

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>



---

# Method 1: Value function iteration

In VFI we approximate the .hi[value function] with some flexible functional form $\Gamma(k_t;b)$ where $b$ is a vector of coefficients

The algorithm has 6 steps

---

# Method 1: Value function iteration

.hi[Step 1:] Select the number of collocation points in each dimension and the domain of the approximation space

--

.hi[Step 2:] Select an initial vector of coefficients $b_0$ with the same number of elements as the collocation grid, and initial guesses for consumption for the solver

--

.hi[Step 3:] Select a rule for convergence

--

.hi[Step 4:] Construct the grid and basis matrix

---

# Method 1: Value function iteration


.hi[Step 5:] While convergence criterion $>$ tolerance **(outer loop [fixed point])**
+ Start iteration $p$
+ For each grid point **(inner loop [right hand side maximization])**
    - Maximize the right hand side of the Bellman equation at each grid point using the approximating value function $\Gamma(k_{t+1};b^{(p)})$ in place of $V(k_{t+1})$
    - Recover the maximized values $V^{(p)}$ at each grid point, conditional on $\Gamma(k_{t+1};b^{(p)})$

...

---

# Method 1: Value function iteration

.hi[Step 5:] While convergence criterion $>$ tolerance **(outer loop, continued)**
+ Fit the polynomial to the maximized values $V^{(p)}$ and recover a new vector of coefficients $\hat{b}^{(p+1)}$.
+ Compute the vector of coefficients $b^{(p+1)}$ for iteration $p+1$ by  
$b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}$ where $\gamma \in (0,1).$ (damping)

--

.hi[Step 6:] Error check your approximation

---

# Functions we will code up

We will need to code up six key functions for all of the algorithms

- `cheb_nodes(n)`: construct degree $n$ collocation grid 
- `cheb_polys(x, n)`: evaluate degree $n$ Chebyshev polynomials
- `construct_basis_matrix(grid, params)`: construct full $n\times n$ Chebyshev basis matrix
- `eval_approx_function(coefficients, grid, params)`: evaluate approximating function at grid points `grid`
- `loop_grid(params, capital_grid, coefficients)`: loop over the collocation grid
- `solve_algorithm(params, basis_inverse, capital_grid, coefficients)`: iterate on the fixed point

---

# Functional forms and parameters

Functional forms
- $u(c_t) = c_t^{1-\eta}/(1-\eta)$
- $f(k_t) = k_t^\alpha$

Parameters
- $\alpha = 0.75$
- $\beta = 0.95$
- $\eta = 2$

Initial capital value: $k_0 = (\alpha \beta)^{1/(1-\alpha)}/2$

---

# Step 1: Select the number of points and domain

If $k_0 = (\alpha \beta)^{1/(1-\alpha)}/2$ what are a logical set of bounds for the capital state?

--

$k^0$ and the steady state level $(\alpha \beta)^{1/(1-\alpha)}$

---

# Step 1: Select the number of points and domain

Put everything in a **named tuple** to make passing things easier

```{julia}
using LinearAlgebra
using Optim
using Plots
params = (alpha = 0.75, # capital share
          beta = 0.95, # discount
          eta = 2, # EMUC
          steady_state = (0.75*0.95)^(1/(1 - 0.75)),
          k_0 = (0.75*0.95)^(1/(1 - 0.75))/2, # initial state
          capital_upper = (0.75*0.95)^(1/(1 - 0.75))*1.01, # upper bound
          capital_lower = (0.75*0.95)^(1/(1 - 0.75))/2, # lower bound
          num_points = 7, # number of grid points
          tolerance = 0.0001)
```



---

# Step 2: Select an initial vector of coefficients $b_0$

In some cases you might have a good guess (e.g. increasing and concave so you know the second value is positive, third value is negative, rest maybe set to zero)

--

Other cases you might not,
guessing zeros effectively turns the initial iteration into a static problem,
the second iteration into a 2 period problem, and so on

--

```{julia}
coefficients = zeros(params.num_points) # # coeffs = # grid points in collocation
```

---

# Step 3: Select a convergence rule

There's a lot of potential options here to determine convergence of the function

--

Relative or absolute change? Or both?

--

Change in the value function? Change in the policy function?

--

Which norm?

--

.hi[Our rule for class:] convergence is when the maximum relative change in value on the grid is < 0.001%

---

# Step 4: Construct the grid and basis matrix

The function `cheb_nodes` from last lecture constructs the grid on $[-1,1]$

--

Recall:

$$x_k = cos\left(\frac{2k-1}{2n}\pi\right),\,\, k = 1,...,n$$

---

# Step 4: Construct the grid and basis matrix

```{julia}
cheb_nodes(n) = cos.(pi * (2*(1:n) .- 1)./(2n));
grid = cheb_nodes(params.num_points) # [-1, 1] grid with n points
```

Our actual capital domain isn't on $[-1,1]$, we need to expand the grid to some arbitrary $[a,b]$ using a function `expand_grid(grid, params)`

---

# Step 4: Construct the grid and basis matrix


```{julia}
expand_grid(grid, params) = # function that expands [-1,1] to [a,b]
   (1 .+ grid)*(params.capital_upper - params.capital_lower)/2 .+ params.capital_lower
capital_grid = expand_grid(grid, params)
```

---

# Step 4: Construct the grid and basis matrix

Make the inverse function to shrink from capital to Chebyshev space `shrink_grid(capital)`

--

```{julia}
shrink_grid(capital) = 
  2*(capital - params.capital_lower)/(params.capital_upper - params.capital_lower) - 1;
shrink_grid.(capital_grid)
```

`shrink_grid` will inherit `params` from wrapper functions

---

# Step 4: Construct the grid and basis matrix

--

`cheb_polys(x, n)` from last lecture gives us the nth degree Chebyshev polynomial at point x

--

```{julia}
# Chebyshev polynomial function
function cheb_polys(x, n)
    if n == 0
        return 1                    # T_0(x) = 1
    elseif n == 1
        return x                    # T_1(x) = x
    else
        cheb_recursion(x, n) =
            2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
        return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
    end
end;
```

---

# Step 4: Construct the grid and basis matrix

`cheb_polys.(grid, n)` gives us the nth degree Chebyshev polynomial at all points on our grid

--

```{julia}
cheb_polys.(grid, 2) # 2nd degree Cheb poly at each grid point
```


---

# Step 4: Construct the grid and basis matrix

In our basis matrix, rows are grid points, columns are basis functions, make a function `construct_basis_matrix(grid, params)` that makes the basis matrix for some arbitrary grid of points

```{julia}
construct_basis_matrix(grid, params) = hcat([cheb_polys.(shrink_grid.(grid), n) for n = 0:params.num_points - 1]...);
basis_matrix = construct_basis_matrix(capital_grid, params)
```

---

# Step 4: Pre-invert your basis matrix

.hi[Pro tip:] you will be using the *exact same* basis matrix in each loop iteration to recover the coefficients: just pre-invert it to save time because inverting the same matrix every loop is costly (especially when large)

```{julia}
basis_inverse = basis_matrix \ I # pre-invert
```

---

# Pre-Step 5: Evaluate the continuation value

--

To maximize the Bellman at each grid point we need to evaluate the value function

We need to make a function `eval_value_function(coefficients, capital, params)` that lets us evaluate the continuation value given a vector of coefficients `coefficients`, a vector of capital nodes `capital`, and the model parameters `params`

--

It needs to:

1. Scale capital back into $[-1,1]$ (the domain of the Chebyshev polynomials)
2. Use the coefficients and Chebyshev polynomials to evaluate the value function

---

# Pre-Step 5: Evaluate the continuation value

```{julia}
# evaluates V on the [-1,1]-equivalent grid
eval_value_function(coefficients, grid, params) = construct_basis_matrix(grid, params) * coefficients;
```

---

# Step 5: Inner loop over grid points

Construct a function `loop_grid(params, capital_grid, coefficients)` that loops over the grid points `capital_grid`
and solves the Bellman given $\Gamma(x;b^{(p)})$

Pseudocode:
```
for each grid point i:
define the Bellman as a closure so it can take in parameters
maximize the Bellman by choosing consumption
store maximized value in a vector v[i]
end

return vector of maximized values v
```

---

# Step 5: Inner loop over grid points

```{julia}
function loop_grid(params, capital_grid, coefficients)
    max_value = similar(coefficients); # initialized max value vector

    # Inner loop over grid points
    for (iteration, capital) in enumerate(capital_grid)

        # Define Bellman as a closure
        function bellman(consumption)
            capital_next = capital^params.alpha - consumption # Next period state
            cont_value = eval_value_function(coefficients, capital_next, params)[1] # Continuation value
            value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value # Utility + continuation value
            return -value_out
        end;

        results = optimize(bellman, 0.00*capital^params.alpha, 0.99*capital^params.alpha) # maximize Bellman
        max_value[iteration] = -Optim.minimum(results) # Store max value in vector
    end
    return max_value
end
```

---

# Step 5: Outer loop iterating on Bellman

Construct a function `solve_vfi(params, basis_inverse, capital_grid, coefficients)` that iterates on `loop_grid` and solves for the coefficient vector $b$ until the maximized values on the grid converge

Pseudocode:
```
while error > tolerance
call loop_grid to get maximized values
use maximized values and basis matrix to get new coefficients
error is maximum relative difference between current and previous maximized values
end

return vector of maximized values v
```

---

# Step 5: Outer loop iterating on Bellman

```{julia}
function solve_vfi(params, basis_inverse, capital_grid, coefficients)
    iteration = 1
    error = 1e10;
    max_value = similar(coefficients);
    value_prev = .1*ones(params.num_points);
    coefficients_store = Vector{Vector}(undef, 1)
    coefficients_store[1] = coefficients
    while error > params.tolerance # Outer loop iterating on Bellman eq
        max_value = loop_grid(params, capital_grid, coefficients) # Inner loop
        coefficients = basis_inverse*max_value # \Psi \ y, recover coefficients
        error = maximum(abs.((max_value - value_prev)./(value_prev))) # compute error
        value_prev = deepcopy(max_value) # save previous values
        if mod(iteration, 5) == 0
            println("Maximum Error of $(error) on iteration $(iteration).")
            append!(coefficients_store, [coefficients])
        end
        iteration += 1
    end
    return coefficients, max_value, coefficients_store
end
```

---

# Step 5: Outer loop iterating on Bellman

```{julia}
solution_coeffs, max_value, intermediate_coefficients =
    solve_vfi(params, basis_inverse, capital_grid, coefficients)
```

---

# Now lets plot our solutions

```{julia}

capital_levels = range(params.capital_lower, params.capital_upper, length = 100);
eval_points = shrink_grid.(capital_levels);

solution = similar(intermediate_coefficients);

# Compute optimal value at all capital grid points
for (iteration, coeffs) in enumerate(intermediate_coefficients)
    solution[iteration] = [coeffs' * [cheb_polys.(capital, n) for n = 0:params.num_points - 1] for capital in eval_points];
end
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
plot(capital_levels, solution[2],
    grid = false,
    legend = false,
    size = (600, 400),
    xlabel = "Capital",
    ylabel = "Value",
    tickfontsize = 14,
    guidefontsize = 14,
    ylims = (minimum(hcat(solution[2:end]...)) , maximum(hcat(solution[2:end]...))),
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
plot!(capital_levels, solution[3],
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
using Plots
gr();
plot!(capital_levels, solution[5],
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
using Plots
gr();
plot!(capital_levels, solution[7],
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
plot!(capital_levels, solution[9],
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
plot!(capital_levels, solution[11],
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
plot!(capital_levels, solution[15],
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
plot!(capital_levels, solution[20],
    linewidth = 4)
```

---

# Plot the value function iterations

```{julia, echo = FALSE}
plot!(capital_levels, solution[end],
    linewidth = 4)
```

---

# Plot the final value function

```{julia, echo = FALSE}
plot(capital_levels, solution[end],
    grid = false,
    legend = false,
    size = (600, 400),
    xlabel = "Capital",
    ylabel = "Value",
    tickfontsize = 14,
    guidefontsize = 14,
    linewidth = 4)
```

---

# Now lets try simulating

```{julia}
function simulate_model(params, solution_coeffs, time_horizon = 100)
    capital_store = zeros(time_horizon + 1)
    consumption_store = zeros(time_horizon)
    capital_store[1] = params.k_0

    for t = 1:time_horizon
        capital = capital_store[t]
        function bellman(consumption)
            capital_next = capital^params.alpha - consumption
            capital_next_scaled = shrink_grid(capital_next)
            cont_value = solution_coeffs' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
            value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
            return -value_out
        end;

        results = optimize(bellman, 0.0, capital^params.alpha)
        consumption_store[t] = Optim.minimizer(results)
        capital_store[t+1] = capital^params.alpha - consumption_store[t]
    end
    return consumption_store, capital_store
end;
```

---

# Now lets try simulating

```{julia, echo=FALSE}
time_horizon = 100;
consumption, capital = simulate_model(params, solution_coeffs, time_horizon);
plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, label = "Consumption", legend = :right, size = (600, 400), grid = false, tickfontsize = 14,
guidefontsize = 14);
plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
plot!(1:time_horizon, params.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Analytic Steady State")
```

---

# The consumption policy function

```{julia}
capital_levels = range(params.capital_lower, params.capital_upper, length = 100);
consumption = similar(capital_levels);

# Compute optimal consumption at all capital grid points
for (iteration, capital) in enumerate(capital_levels)

    function bellman(consumption)
        capital_next = capital^params.alpha - consumption
        capital_next_scaled = shrink_grid(capital_next)
        cont_value = solution_coeffs' * [cheb_polys.(capital_next_scaled, n) for n = 0:params.num_points - 1]
        value_out = (consumption)^(1-params.eta)/(1-params.eta) + params.beta*cont_value
        return -value_out
    end

    results = optimize(bellman, 0., capital^params.alpha)

    consumption[iteration] = Optim.minimizer(results)
end;
```

---

# The consumption policy function

```{julia, echo = FALSE}
plot(capital_levels, consumption,
    grid = false,
    legend = false,
    size = (600, 400),
    xlabel = "Capital",
    ylabel = "Consumption",
    tickfontsize = 14,
    guidefontsize = 14,
    linewidth = 4)
```

---

class: inverse, center, middle
name: fpi

# Fixed point iteration

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>


---

# Method 2: Fixed point iteration

In FPI we generally approximate a policy function with some flexible functional form $\Gamma(k_t;b)$ where $b$ is a vector of coefficients

--

FPI re-casts equilibrium conditions of the model as a fixed point

--

We then perform multi-dimensional function iteration to solve for the fixed point

--

It does not bear a terrible computational cost and is derivative-free

--

The drawback is that it will not always converge and may be unstable

--

This can be solved by .hi[damping]


---

# Eq condition: Euler equation

Standard procedure is to iterate on the Euler equation

$$C(k_t) = u'^{(-1)}\left(\beta u'(C(k_{t+1})) f'(k_{t+1}(C(k_t),k_t))\right)$$

---

# Method 2: Fixed point iteration

The algorithm has 6 steps, very similar to VFI


---

# Method 2: Fixed point iteration

.hi[Step 1:] Select the number of collocation points in each dimension and the domain of the approximation space

--

.hi[Step 2:] Select an initial vector of coefficients $b_0$ with the same number of elements as the collocation grid

--

.hi[Step 3:] Select a rule for convergence

--

.hi[Step 4:] Construct the grid and basis matrix

---

# Method 2: Fixed point iteration

.hi[Step 5:] While convergence criterion $>$ tolerance **(outer loop)**
  + Start iteration $p$
  + For each grid point **(inner loop)**
    + Substitute $C(k_{t+1};b^{(p)})$ into the right hand side of the Euler fixed point
    + Recover the LHS values of consumption at each grid point
  + Fit the polynomial to the values and recover a new vector of coefficients $\hat{b}^{(p+1)}$.
  + Compute the vector of coefficients $b^{(p+1)}$ for iteration $p+1$ by
  $b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}$ where $\gamma \in (0,1).$ (damping)

--

.hi[Step 6:] Error check your approximation

Notice: we did not have to perform a maximization step .hi-red[anywhere],
this leads to big speed gains

---

# Step 1: Select the number of points and domain

Put everything in a **named tuple** to make passing things easier

```{julia}
using LinearAlgebra
using Optim
using Plots
params_fpi = (alpha = 0.75, beta = 0.95, eta = 2, damp = 0.7,
                steady_state = (0.75*0.95)^(1/(1-0.75)), k_0 = (0.75*0.95)^(1/(1-0.75))*0.5,
                capital_upper = (0.75*0.95)^(1/(1-0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1-0.75))*0.5,
                num_points = 5, tolerance = 0.00001)
shrink_grid(capital) = 2*(capital - params_fpi.capital_lower)/(params_fpi.capital_upper - params_fpi.capital_lower) - 1
```

---

# Step 2: Select an initial vector of coefficients $b_0$

```{julia}
coefficients = zeros(params_fpi.num_points)
```

---

# Step 3: Select a convergence rule

Rule: maximum change in consumption on the grid < 0.001%

---

# Step 4: Construct the grid and basis matrix

The function `cheb_nodes` from last lecture constructs the grid on $[-1,1]$

--

Recall:

$$x_k = cos\left(\frac{2k-1}{2n}\pi\right),\,\, k = 1,...,n$$

---

# Step 4: Construct the grid and basis matrix

```{julia}
cheb_nodes(n) = cos.(pi * (2*(1:n) .- 1)./(2n));
grid = cheb_nodes(params_fpi.num_points) # [-1, 1] grid with n points
```

Our actual capital domain isn't on $[-1,1]$, we need to expand the grid to some arbitrary $[a,b]$

---

# Step 4: Construct the grid and basis matrix


```{julia}
expand_grid(grid, params_fpi) = # function that expands [-1,1] to [a,b]
   (1 .+ grid)*(params_fpi.capital_upper - params_fpi.capital_lower)/2 .+ params_fpi.capital_lower
capital_grid = expand_grid(grid, params_fpi)
```

---

# Step 4: Construct the grid and basis matrix

Make the inverse function to shrink from capital to Chebyshev space `shrink_grid(capital, params)`

--

```{julia}
shrink_grid(capital) = 
  2*(capital - params_fpi.capital_lower)/(params_fpi.capital_upper - params_fpi.capital_lower) - 1;
shrink_grid.(capital_grid)
```

`shrink_grid` will inherit `params_fpi` from wrapper functions

---

# Step 4: Construct the grid and basis matrix

--

`cheb_polys(x, n)` from last lecture gives us the nth degree Chebyshev polynomial at point x

--

```{julia}
# Chebyshev polynomial function
function cheb_polys(x, n)
    if n == 0
        return 1                    # T_0(x) = 1
    elseif n == 1
        return x                    # T_1(x) = x
    else
        cheb_recursion(x, n) =
            2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
        return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
    end
end;
```

---

# Step 4: Construct the grid and basis matrix

`cheb_polys.(grid, n)` gives us the nth degree Chebyshev polynomial at all points on our grid

--

```{julia}
cheb_polys.(grid, 2) # 2nd degree Cheb poly at each grid point
```


---

# Step 4: Construct the grid and basis matrix

In our basis matrix, rows are grid points, columns are basis functions, make a function `construct_basis_matrix(grid, params)` that makes the basis matrix for some arbitrary grid of points

```{julia}
construct_basis_matrix(grid, params_fpi) = hcat([cheb_polys.(shrink_grid.(grid), n) for n = 0:params_fpi.num_points - 1]...);
basis_matrix = construct_basis_matrix(capital_grid, params_fpi)
```

---

# Step 4: Pre-invert your basis matrix

.hi[Pro tip:] you will be using the *exact same* basis matrix in each loop iteration to recover the coefficients: just pre-invert it to save time because inverting the same matrix every loop is costly (especially when large)

```{julia}
basis_inverse = basis_matrix \ I # pre-invert
```

---

# Pre-Step 5: Evaluate the policy function

We need to make a function `eval_policy_function(coefficients, capital, params_fpi)` that lets us evaluate the policy function given a vector of coefficients `coefficients`, a vector of capital nodes `capital`, and the model parameters `params_fpi`

--

It needs to:

1. Scale capital back into $[-1,1]$ (the domain of the Chebyshev polynomials)
2. Use the coefficients and Chebyshev polynomials to evaluate the value function

---

# Pre-Step 5: Evaluate the policy function

```{julia}
# evaluates V on the [-1,1]-equivalent grid
eval_policy_function(coefficients, capital, params_fpi) = 
    construct_basis_matrix(capital, params_fpi) * coefficients;
```

---

# Step 5: Loop

Construct a function `consumption_euler(params_fpi, capital, coefficients)` that evaluates the RHS of the Euler

--

```{julia}
function consumption_euler(params_fpi, capital, coefficients)
    # RHS: Current consumption given current capital
    consumption = eval_policy_function(coefficients, capital, params_fpi)[1]
    # RHS: Next period's capital given current capital and consumption
    capital_next = capital^params_fpi.alpha - consumption
    # RHS: Next period's consumption given current capital and consumption
    consumption_next = eval_policy_function(coefficients, capital_next, params_fpi)[1]
    consumption_next = max(1e-10, consumption_next)
    # LHS: Next period's consumption from Euler equation
    consumption_lhs = (
      params_fpi.beta * consumption_next^(-params_fpi.eta) * params_fpi.alpha*(capital_next).^(params_fpi.alpha-1)
        ).^(-1/params_fpi.eta)
    return consumption_lhs
end
```

---

# Step 5: Loop

Construct a function `loop_grid_fpi(params_fpi, capital_grid, coefficients)` that loops over the grid points and evaluates the RHS of the Euler given $\Psi(x;b^{(p)})$

--

```{julia}
function loop_grid_fpi(params_fpi, capital_grid, coefficients)

    consumption = similar(coefficients)

    # Compute next period's consumption from the Euler equation
    for (iteration, capital) in enumerate(capital_grid)
        consumption[iteration] = consumption_euler(params_fpi, capital, coefficients)
    end
    return consumption
end
```

---

# Step 5: Loop

Construct a function `solve_fpi(params_fpi, basis_inverse, capital_grid, coefficients)` that iterates on `loop_grid_fpi` and solves for the coefficient vector $b$ until the consumption values on the grid converge

```{julia}
function solve_fpi(params_fpi, basis_inverse, capital_grid, coefficients)
    error = 1e10
    iteration = 1
    consumption = similar(coefficients)
    consumption_prev, coefficients_prev = similar(coefficients), similar(coefficients)
    coefficients_store = Vector{Vector}(undef, 1)
    coefficients_store[1] = coefficients
    while error > params_fpi.tolerance
        consumption = loop_grid_fpi(params_fpi, capital_grid, coefficients)
        if iteration > 1
            coefficients = params_fpi.damp*(basis_inverse*consumption) + (1 - params_fpi.damp)*coefficients_prev
        else
            coefficients = basis_inverse*consumption
        end
        error = maximum(abs.((consumption - consumption_prev)./(consumption_prev)))
        coefficients_prev, consumption_prev = deepcopy(coefficients), deepcopy(consumption)
        if mod(iteration, 5) == 0
            println("Maximum Error of $(error) on iteration $(iteration).")
            append!(coefficients_store, [coefficients])
        end
        iteration += 1
    end
    return coefficients, consumption, coefficients_store
end
```

---

# Step 5: Loop

```{julia}
solution_coeffs, consumption, intermediate_coefficients =
    solve_fpi(params_fpi, basis_inverse, capital_grid, coefficients)
```

---

# Now lets plot our solutions

```{julia}
capital_levels = range(params_fpi.capital_lower, params_fpi.capital_upper, length = 100);
eval_points = shrink_grid.(capital_levels);
solution = similar(intermediate_coefficients);

for (iteration, coeffs) in enumerate(intermediate_coefficients)
    solution[iteration] = [coeffs'*[cheb_polys.(capital, n) for n = 0:params_fpi.num_points - 1] for capital in eval_points];
end
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot(capital_levels, solution[2],
     grid = false,
     legend = false,
     size = (600, 400),
     xlabel = "Capital",
     ylabel = "Consumption",
     tickfontsize = 14,
     guidefontsize = 14,
     ylims = (minimum(hcat(solution[2:end]...)) , maximum(hcat(solution[2:end]...))),
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[4],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
using Plots
gr();
plot!(capital_levels, solution[7],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
using Plots
gr();
plot!(capital_levels, solution[10],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[13],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[16],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[19],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[22],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[end],
     linewidth = 4)
```

---

# Plot the final consumption policy function

```{julia, echo = FALSE}
using Plots
gr();
plot(capital_levels, solution[end],
     grid = false,
     legend = false,
     size = (600, 400),
     xlabel = "Capital",
     ylabel = "Consumption",
     tickfontsize = 14,
     guidefontsize = 14,
     linewidth = 4)
```

---

# Now lets try simulating

```{julia}
function simulate_model(params, solution_coeffs, time_horizon = 100)
    capital_store = zeros(time_horizon + 1)
    consumption_store = zeros(time_horizon)
    capital_store[1] = params.k_0

    for t = 1:time_horizon
        capital = capital_store[t]
        consumption_store[t] = consumption_euler(params, capital, solution_coeffs)
        capital_store[t+1] = capital^params.alpha - consumption_store[t]
    end

    return consumption_store, capital_store

end
```

---

# Now lets try simulating

```{julia, results = 'hide'}
time_horizon = 100;
consumption, capital = simulate_model(params_fpi, solution_coeffs, time_horizon);
plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, tickfontsize = 14, guidefontsize = 14, label = "Consumption", legend = :right, grid = false, size = (500, 300));
plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
plot!(1:time_horizon, params_fpi.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Steady State Capital")
```

---

# Now lets try simulating

```{julia, echo = FALSE}
time_horizon = 100;
consumption, capital = simulate_model(params_fpi, solution_coeffs, time_horizon);
plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, tickfontsize = 14, guidefontsize = 14, label = "Consumption", legend = :right, grid = false, size = (500, 300));
plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
plot!(1:time_horizon, params_fpi.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Steady State Capital")
```

---

class: inverse, center, middle
name: ti

# Time iteration

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>


---

# Method 3: Time iteration

In time iteration we approximate the *policy function* with some flexible functional form $\Psi(k_t;b)$ where $b$ is a vector of coefficients

--

The difference vs FPI is we use root-finding techniques on our $n$ node collocation grid where
we search for the .hi-red[scalar] $c^{(p+1)}(k_t)$ that solves
$$u'(c^{(p+1)}(k^j_t)) = \beta u'(C^{(p)}(f(k^j_t)-c^{(p+1)}(k^j_t))) f'(f(k^i_t)-c^{(p+1)}(k^j_t))$$

for $j=1,\dots,N$

---

# Method 3: Time iteration

$$u'(c^{(p+1)}(k^j_t)) = \beta u'(C^{(p)}(f(k^j_t)-c^{(p+1)}(k^j_t))) f'(f(k^i_t)-c^{(p+1)}(k^j_t))$$

$C^{(p)}()$ is our current approximation to the policy function, and we are searching for a .hi-red[scalar] $c^{(p+1)}(k^j_t)$, given our collocation node $k_t^j$, that solves the Euler equation root-finding problem

--

In the Euler equation $c^{(p+1)}$ corresponds to today's policy function
while $C^{(p)}$ corresponds to tomorrow's policy function: we are searching for today's policy that satisfies the Euler equation

---

# Method 3: Time iteration

.hi[Step 1:] Select the number of collocation points in each dimension and the domain of the approximation space

--

.hi[Step 2:] Select an initial vector of coefficients $b_0$ with the same number of elements as the collocation grid, and initial guesses for consumption for the root-finder

--

.hi[Step 3:] Select a rule for convergence

--

.hi[Step 4:] Construct the grid and basis matrix

---

# Method 3: Time iteration

.hi[Step 5:] While convergence criterion $>$ tolerance **(outer loop [fixed point])**
  + Start iteration $p$
  + For each grid point **(inner loop [rootfinding])**
    + Substitute $C(k^j_{t+1};b^{(p)})$ in for $t+1$ consumption
    + Recover the $c^{(p+1)}(k^j_t) \in \mathbb{R}$ scalar values that satisfy the equation
  + Fit the polynomial to the values and recover a new vector of coefficients $\hat{b}^{(p+1)}$
  + Compute the vector of coefficients $b^{(p+1)}$ for iteration $p+1$ by
  $b^{(p+1)} = (1-\gamma) b^{(p)} + \gamma \hat{b}^{(p+1)}$ where $\gamma \in (0,1)$ (damping)
  
.hi[Step 6:] Error check your approximation

---

# Step 1: Select the number of points and domain

Put everything in a **named tuple** to make passing things easier

```{julia}
using LinearAlgebra, Optim, Plots, Roots
params_ti = (alpha = 0.75, beta = 0.95, eta = 2, damp = 0.7,
                steady_state = (0.75*0.95)^(1/(1-0.75)), k_0 = (0.75*0.95)^(1/(1-0.75))*0.5,
                capital_upper = (0.75*0.95)^(1/(1-0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1-0.75))*0.5,
                num_points = 6, tolerance = 0.00001)
```

---

# Step 2: Select an initial vector of coefficients $b_0$

In some cases you might have a good guess (e.g. increasing and concave so you know the second value is positive, third value is negative, rest maybe set to zero)

--

Other cases you might not,
guessing zeros effectively turns the initial iteration into a static problem,
the second iteration into a 2 period problem, and so on

--

```{julia}
coefficients = zeros(params_ti.num_points)
```

---

# Step 3: Select a convergence rule

There's a lot of potential options here to determine convergence of the function

--

Relative or absolute change? Or both?

--

Change in the value function? Change in the policy function?

--

Which norm?

--

.hi[Our rule for class:] convergence is when the maximum relative change in value on the grid is < 0.001%

---

# Step 4: Construct the grid and basis matrix

The function `cheb_nodes` constructs the grid on $[-1,1]$

--

Recall:

$$x_k = cos\left(\frac{2k-1}{2n}\pi\right),\,\, k = 1,...,n$$

--

```{julia}
cheb_nodes(n) = cos.(pi * (2*(1:n) .- 1)./(2n))
grid = cheb_nodes(params_ti.num_points) # [-1, 1] grid
```
---

# Step 4: Construct the grid and basis matrix

But we need to expand the grid from $[-1,1]$ to our actual capital domain

--

```{julia}
expand_grid(grid, params_ti) = (1 .+ grid)*(params_ti.capital_upper - params_ti.capital_lower)/2 .+ params_ti.capital_lower
capital_grid = expand_grid(grid, params_ti)
```

---

# Step 4: Construct the grid and basis matrix

Make the inverse function to shrink from capital to Chebyshev space `shrink_grid(capital)`

--

```{julia}
shrink_grid(capital) = 
  2*(capital - params_ti.capital_lower)/(params_ti.capital_upper - params_ti.capital_lower) - 1;
shrink_grid.(capital_grid)
```

`shrink_grid` will inherit `params_ti` from wrapper functions

---

# Step 4: Construct the grid and basis matrix

Use `cheb_polys` to construct the basis matrix

```{julia}
# Chebyshev polynomial function
function cheb_polys(x, n)
    if n == 0
        return 1                    # T_0(x) = 1
    elseif n == 1
        return x                    # T_1(x) = x
    else
        cheb_recursion(x, n) =
            2x.*cheb_polys.(x, n - 1) .- cheb_polys.(x, n - 2)
        return cheb_recursion(x, n) # T_n(x) = 2xT_{n-1}(x) - T_{n-2}(x)
    end
end;
```



---

# Step 4: Construct the grid and basis matrix

In our basis matrix, rows are grid points, columns are basis functions, make a function `construct_basis_matrix(grid, params)` that makes the basis matrix for some arbitrary grid of points

```{julia}
construct_basis_matrix(grid, params_ti) = hcat([cheb_polys.(shrink_grid.(grid), n) for n = 0:params_ti.num_points - 1]...);
basis_matrix = construct_basis_matrix(capital_grid, params_ti)
```

---

# Step 4: Pre-invert your basis matrix

.hi[Pro tip:] you will be using the *exact same* basis matrix in each loop iteration to recover the coefficients: just pre-invert it to save time because inverting the same matrix every loop is costly (especially when large)

```{julia}
basis_inverse = basis_matrix \ I # pre-invert
```

---

# Pre-Step 5: Evaluate the policy function

We need to make a function `eval_policy_function(coefficients, capital, params_ti)` that lets us evaluate the policy function given a vector of coefficients `coefficients`, a vector of capital nodes `capital`, and the model parameters `params_ti`

--

It needs to:

1. Scale capital back into $[-1,1]$ (the domain of the Chebyshev polynomials)
2. Use the coefficients and Chebyshev polynomials to evaluate the value function

---

# Pre-Step 5: Evaluate the policy function

```{julia}
# evaluates V on the [-1,1]-equivalent grid
eval_policy_function(coefficients, capital, params_ti) = 
    construct_basis_matrix(capital, params_ti) * coefficients;
```

---

# Step 5: Loop

Construct a function `loop_grid_ti(params_ti, capital_grid, coefficients)` that loops over the grid points and solves the Euler given $\Psi(x;b^{(p)})$

---

# Step 5: Loop

```{julia}
function loop_grid_ti(params_ti, capital_grid, coefficients)
    consumption = similar(coefficients)
    for (iteration, capital) in enumerate(capital_grid)
        function consumption_euler(consumption_guess)
            capital_next = capital^params_ti.alpha - consumption_guess
            # Next period consumption based on approximating policy function
            consumption_next = eval_policy_function(coefficients, capital_next, params_ti)[1]
            consumption_next = max(1e-10, consumption_next)
            # Organize Euler so it's g(c,k) = 0
            euler_error = consumption_guess^(-params_ti.eta) /
                (params_ti.beta*consumption_next^(-params_ti.eta)*params_ti.alpha*(capital_next)^(params_ti.alpha - 1)) - 1
            return euler_error
        end
        # Search over consumption such that Euler = 0
        consumption[iteration] = fzero(consumption_euler, 0., capital)
    end
    return consumption
end
```

---

# Step 5: Loop

Construct a function `solve_ti(params_fpi, basis_inverse, capital_grid, coefficients)` that iterates on `loop_grid_ti` and solves for the coefficient vector $b$ until the scalar $c$ values on the grid converge

---

# Step 5: Loop

```{julia}
function solve_ti(params_ti, basis_inverse, capital_grid, coefficients)
    error = 1e10
    iteration = 1
    consumption = similar(coefficients)
    consumption_prev, coefficients_prev = similar(coefficients), similar(coefficients)
    coefficients_store = Vector{Vector}(undef, 1)
    coefficients_store[1] = coefficients
    while error > params_ti.tolerance
        consumption = loop_grid_ti(params_ti, capital_grid, coefficients)
        if iteration > 1
            coefficients = params_ti.damp*(basis_inverse*consumption) + (1 - params_ti.damp)*coefficients_prev
        else
            coefficients = basis_inverse*consumption
        end
        error = maximum(abs.((consumption - consumption_prev)./(consumption_prev)))
        consumption_prev, coefficients_prev = deepcopy(consumption), deepcopy(coefficients)
        if mod(iteration, 5) == 0
            println("Maximum Error of $(error) on iteration $(iteration).")
            append!(coefficients_store, [coefficients])
        end
        iteration += 1
    end
    return coefficients, consumption, coefficients_store
end
```

---

# Step 5: Loop

```{julia}
solution_coeffs, consumption, intermediate_coefficients =
    solve_ti(params_ti, basis_inverse, capital_grid, coefficients)
```

---

# Now lets plot our solutions

```{julia}
capital_levels = range(params_ti.capital_lower, params_ti.capital_upper, length = 100);
eval_points = shrink_grid.(capital_levels);
solution = similar(intermediate_coefficients);

for (iteration, coeffs) in enumerate(intermediate_coefficients)
    solution[iteration] = [coeffs' * [cheb_polys.(capital, n) for n = 0:params_ti.num_points - 1] for capital in eval_points];
end
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
using Plots
plot(capital_levels, solution[2],
     grid = false,
     legend = false,
     size = (600, 400),
     xlabel = "Capital",
     ylabel = "Consumption",
     tickfontsize = 14,
     guidefontsize = 14,
     ylims = (minimum(hcat(solution[2:end]...)) , maximum(hcat(solution[2:end]...))),
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[4],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
using Plots
gr();
plot!(capital_levels, solution[7],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
using Plots
gr();
plot!(capital_levels, solution[10],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[13],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[16],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[19],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[22],
     linewidth = 4)
```

---

# Plot the consumption policy function

```{julia, echo = FALSE}
plot!(capital_levels, solution[end],
     linewidth = 4)
```

---

# Plot the final consumption policy function

```{julia, echo = FALSE}
using Plots
gr();
plot(capital_levels, solution[end],
     grid = false,
     legend = false,
     size = (600, 400),
     xlabel = "Capital",
     ylabel = "Consumption",
     tickfontsize = 14,
     guidefontsize = 14,
     linewidth = 4)
```

---

# Now lets try simulating

```{julia}
function simulate_model(params_ti, solution_coeffs, time_horizon = 100)
    capital_store = zeros(time_horizon + 1)
    consumption_store = zeros(time_horizon)
    capital_store[1] = params_ti.k_0

    for t = 1:time_horizon
        capital = capital_store[t]
        consumption_store[t] = eval_policy_function(solution_coeffs, capital, params_ti)[1]
        capital_store[t+1] = capital^params_ti.alpha - consumption_store[t]
    end

    return consumption_store, capital_store
end;
```

---

# Now lets try simulating

```{julia, results = 'hide'}
time_horizon = 100;
consumption, capital = simulate_model(params_ti, solution_coeffs, time_horizon);
plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, tickfontsize = 14, guidefontsize = 14, label = "Consumption", legend = :right, grid = false, size = (500, 300));
plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
plot!(1:time_horizon, params_ti.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Steady State Capital")
```

---

# Now lets try simulating

```{julia, echo = FALSE}
time_horizon = 100;
consumption, capital = simulate_model(params_ti, solution_coeffs, time_horizon);
plot(1:time_horizon, consumption, color = :red, linewidth = 4.0, tickfontsize = 14, guidefontsize = 14, label = "Consumption", legend = :right, grid = false, size = (500, 300));
plot!(1:time_horizon, capital[1:end-1], color = :blue, linewidth = 4.0, linestyle = :dash, label = "Capital");
plot!(1:time_horizon, params_ti.steady_state*ones(time_horizon), color = :purple, linewidth = 2.0, linestyle = :dot, label = "Steady State Capital")
```

---

class: inverse, center, middle
name: discrete

# Discretization

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>


---

# A short overview of discretization + VFI

When we use discretization methods we create a grid on our state space, typically evenly spaced

--

This becomes our .hi[actual] state space, not just collocation points

--

How does it work?

---

# A short overview of discretization + VFI

The discretized state space implies a discretized control space

--

If there are only a finite number of states tomorrow conditional on the current state,
then there is only a finite number of valid controls

--

This makes solving easy!


---

# A short overview of discretization + VFI

Search over all possible controls today until you find the one that yields the highest value of the RHS of the Bellman:
just requires looping and a max operator

--

The maximized value is the new value of this discretized state

--

3 loops now: outer VFI loop, middle capital grid loop, inner consumption loop

---

# Discretizing the state space

```{julia}
using LinearAlgebra
using Optim
using Plots
params_dis = (alpha = 0.75, beta = 0.95, eta = 2,
                steady_state = (0.75*0.95)^(1/(1 - 0.75)), k_0 = (0.75*0.95)^(1/(1 - 0.75))*.75,
                capital_upper = (0.75*0.95)^(1/(1 - 0.75))*1.5, capital_lower = (0.75*0.95)^(1/(1 - 0.75))/2,
                tolerance = 0.0001, max_iterations = 1000)
```

---

# Discretizing the state space

```{julia}
function iterate_value(grid, params)
    grid_size = size(grid, 1)
    V, V_prev = zeros(grid_size, 1), zeros(grid_size, 1)
    V_store = Array{Float64}(undef, grid_size, params.max_iterations)
    max_diff = 1e10
    it = 1
    while max_diff > params.tolerance && it <= params.max_iterations # iterate on the value function
        for (iteration, grid_point) in enumerate(grid) # iterate across the capital grid
            # possible consumption values (output + remaining capital - capital next period)
            c_vec = grid_point.^params.alpha .- grid
            value_max = -Inf
            # find consumption that maximizes the right hand side of the Bellman, search over ones with positive consumption
            for (it_inner, consumption) in enumerate(c_vec[c_vec .> 0]) # iterate across possible consumption values
                value_temp = consumption^(1 - params.eta)/(1 - params.eta) + params.beta*V[it_inner]
                value_max = max(value_temp, value_max)
            end
            V[iteration] = value_max
        end
        max_diff = maximum(abs.(V .- V_prev))
        if mod(it,10) == 0
            println("Current maximum value difference at iteration $it is $max_diff.")
        end
        V_prev = copy(V)
        V_store[:,it] = V
        if it == params.max_iterations
            println("Hit maximum iterations")
            break
        end
        it += 1
    end
    V_store = V_store[:, 1:it-1]
    return V, V_store
end
```

---

# Discretizing the state space

```{julia, eval=FALSE}
        max_diff = maximum(abs.((V .- V_prev)./V_prev))
        if mod(it,10) == 0
            println("Current maximum value difference at iteration $it is $max_diff.")
        end
        V_prev = copy(V)
        V_store[:,it] = V
        if it == params.max_iterations
            println("Hit maximum iterations")
            break
        end
        it += 1
    end
    V_store = V_store[:, 1:it-1]
    return V, V_store
end
```

---

# Discretizing the state space

```{julia}
grid_size = 3;
grid = collect(range(params_dis.capital_lower,
    stop = params_dis.capital_upper,
    length = grid_size))

value, v_store = @time iterate_value(grid, params_dis)

```

---

# The value function: every 20 iterations

```{julia, echo=FALSE}
plot(grid, v_store[:,1:20:end],
    grid = false,
    legend = false,
    size = (600, 400),
    xlabel = "Capital",
    ylabel = "Value",
    tickfontsize = 14,
    guidefontsize = 14,
    linewidth = 4)
```

---

# The value function: final

```{julia, echo=FALSE}
plot(grid, v_store[:,end],
    grid = false,
    legend = false,
    size = (600, 400),
    xlabel = "Capital",
    ylabel = "Value",
    tickfontsize = 14,
    guidefontsize = 14,
    linewidth = 4)
```

---

# Discretizing the state space

```{julia}
grid_size = 100;
grid = collect(range(params_dis.capital_lower,
    stop = params_dis.capital_upper,
    length = grid_size));

value, v_store = @time iterate_value(grid, params_dis)

```

---

# The value function: every 20 iterations

```{julia, echo=FALSE}
plot(grid, v_store[:,1:20:end],
    grid = false,
    legend = false,
    size = (600, 400),
    xlabel = "Capital",
    ylabel = "Value",
    tickfontsize = 14,
    guidefontsize = 14,
    linewidth = 4)
```

---

# The value function: final

```{julia, echo=FALSE}
plot(grid, v_store[:,end],
    grid = false,
    legend = false,
    size = (600, 400),
    xlabel = "Capital",
    ylabel = "Value",
    tickfontsize = 14,
    guidefontsize = 14,
    linewidth = 4)
```